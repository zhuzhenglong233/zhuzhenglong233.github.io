<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MyBatis 映射配置解析以及动态SQL配置案例]]></title>
    <url>%2F2018%2F04%2F05%2FMyBatis-%E6%98%A0%E5%B0%84%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E4%BB%A5%E5%8F%8A%E5%8A%A8%E6%80%81SQL%E9%85%8D%E7%BD%AE%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[什么是 MyBatis ？MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 MyBatis的 Git 代码库corp数据库全部表结构与数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859DROP DATABASE IF EXISTS `corp`;CREATE DATABASE `corp`;USE `corp`;-- 部门 CREATE TABLE `depa` ( `id` INT AUTO_INCREMENT PRIMARY KEY, `depa_name` NVARCHAR (50) NOT NULL) ;-- 职员 CREATE TABLE `emp` ( `id` INT AUTO_INCREMENT PRIMARY KEY, `emp_name` NVARCHAR (50) NOT NULL, `depa_id` INT NOT NULL) ;-- 职位 CREATE TABLE `post` ( `id` INT AUTO_INCREMENT PRIMARY KEY, `post_name` NVARCHAR (50) NOT NULL) ;-- 职员职位 CREATE TABLE `emp_post` ( `emp_id` INT NOT NULL, `post_id` INT NOT NULL) ;INSERT INTO `depa`(`depa_name`) VALUES('销售部');INSERT INTO `depa`(`depa_name`) VALUES('美工部');INSERT INTO `emp`(`emp_name`,`depa_id`) VALUES('张三',2);INSERT INTO `emp`(`emp_name`,`depa_id`) VALUES('李四',1);INSERT INTO `emp`(`emp_name`,`depa_id`) VALUES('王五',1);INSERT INTO `emp`(`emp_name`,`depa_id`) VALUES('赵六',1);INSERT INTO `post`(`post_name`) VALUES('职员');INSERT INTO `post`(`post_name`) VALUES('主管');INSERT INTO `post`(`post_name`) VALUES('经理');INSERT INTO `post`(`post_name`) VALUES('部门经理');INSERT INTO `emp_post`(`emp_id`,`post_id`) VALUES(1,1);INSERT INTO `emp_post`(`emp_id`,`post_id`) VALUES(2,2);INSERT INTO `emp_post`(`emp_id`,`post_id`) VALUES(3,3);INSERT INTO `emp_post`(`emp_id`,`post_id`) VALUES(4,4);INSERT INTO `emp_post`(`emp_id`,`post_id`) VALUES(1,4);SELECT * FROM `depa`;SELECT * FROM `emp`;SELECT * FROM `post`;SELECT * FROM `emp_post`;DROP TABLE `depa`;DROP TABLE `emp`;DROP TABLE `post`;DROP TABLE `emp_post`; pom.xml12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com&lt;/groupId&gt; &lt;artifactId&gt;Corp&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; MybatisUtil Mybatis工具类1234567891011121314151617181920212223242526package com.util;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;public class MybatisUtil &#123; private static SqlSessionFactory sessionFactory; static &#123; try &#123; InputStream inputStream = Resources.getResourceAsStream("mybatis-config.xml"); sessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static SqlSession getSession() &#123; return sessionFactory.openSession(false);//true为自动提交事务 &#125;&#125; Depa 部门实体类12345678910111213141516171819202122232425262728293031323334353637383940414243package com.entity;import java.util.ArrayList;import java.util.List;public class Depa &#123; private Integer id; private String depa_name; private List&lt;Emp&gt; emps = new ArrayList&lt;Emp&gt;(); @Override public String toString() &#123; return "Depa&#123;" + "id=" + id + ", depa_name='" + depa_name + '\'' + ", emps=" + emps + '&#125;'; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getDepa_name() &#123; return depa_name; &#125; public void setDepa_name(String depa_name) &#123; this.depa_name = depa_name; &#125; public List&lt;Emp&gt; getEmps() &#123; return emps; &#125; public void setEmps(List&lt;Emp&gt; emps) &#123; this.emps = emps; &#125;&#125; 对应 Depa 部门实体类 的实现接口 DepaDao 接口类123456789package com.dao;import com.entity.Depa;import java.util.List;public interface DepaDao &#123; List&lt;Depa&gt; getAll();&#125; 对应 Depa 部门实体类 的映射配置文件 DepaMapper.xml12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--namespace mapper接口 必填 随便填值 防止SQL语句ID重名--&gt;&lt;mapper namespace="com.dao.DepaDao"&gt; &lt;!--&lt;insert id=""&gt;&lt;/insert&gt;--&gt; &lt;!--&lt;delete id=""&gt;&lt;/delete&gt;--&gt; &lt;!--&lt;update id=""&gt;&lt;/update&gt;--&gt; &lt;!--resultType 返回类型 实体类全限定类名--&gt; &lt;select id="getAll" resultMap="DepaMapper"&gt; SELECT *,e.`id` eId,d.`id` dId FROM depa d INNER JOIN emp e ON d.`id`=e.`depa_id` &lt;/select&gt; &lt;!--type 为resultMap返回类型--&gt; &lt;resultMap id="DepaMapper" type="Depa"&gt; &lt;!--column 为数据库查到后取的别名 property 为type对象对应属性名--&gt; &lt;result column="dId" property="id"/&gt; &lt;!--因为数据库的字段与实体类属性名一致--&gt; &lt;!--所以在 mybatis-config.xml 配置 &lt;setting name="autoMappingBehavior" value="FULL"/&gt;--&gt; &lt;!--达到 自动映射行为 : 局部的PARTIAL 重复的 &lt;result/&gt; 可以省略--&gt; &lt;!--&lt;result column="" property=""/&gt;--&gt; &lt;!--收集 一对多--&gt; &lt;!--property 为type对象对应属性名 javaType 为所属类型--&gt; &lt;collection property="emps" javaType="Emp"&gt; &lt;!--column 为数据库查到后取的别名 property 为javaType对象对应属性名--&gt; &lt;result column="" property=""/&gt; &lt;!--因为数据库的字段与实体类属性名一致--&gt; &lt;!--所以在 mybatis-config.xml 配置 &lt;setting name="autoMappingBehavior" value="FULL"/&gt;--&gt; &lt;!--达到 自动映射行为 : 全部FULL 重复的 &lt;result/&gt; 可以省略--&gt; &lt;result column="eId" property="id"/&gt; &lt;/collection&gt; &lt;/resultMap&gt;&lt;/mapper&gt; Emp 职员实体类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.entity;import java.util.ArrayList;import java.util.List;public class Emp &#123; private Integer id; private String emp_name; private Depa depa_id; private List&lt;Post&gt; posts = new ArrayList&lt;Post&gt;(); @Override public String toString() &#123; return "Emp&#123;" + "id=" + id + ", emp_name='" + emp_name + '\'' + ", depa_id=" + depa_id + ", posts=" + posts + '&#125;'; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getEmp_name() &#123; return emp_name; &#125; public void setEmp_name(String emp_name) &#123; this.emp_name = emp_name; &#125; public Depa getDepa_id() &#123; return depa_id; &#125; public void setDepa_id(Depa depa_id) &#123; this.depa_id = depa_id; &#125; public List&lt;Post&gt; getPosts() &#123; return posts; &#125; public void setPosts(List&lt;Post&gt; posts) &#123; this.posts = posts; &#125;&#125; 对应 Emp 职员实体类 的实现接口 EmpDao 接口类123456789101112131415161718package com.dao;import com.entity.Emp;import java.util.List;import java.util.Map;public interface EmpDao &#123; List&lt;Emp&gt; getAll(); Integer saveOrUpdate(Emp emp); Integer del(Integer[] idArray); List&lt;Emp&gt; getByNames(List names); List&lt;Emp&gt; getByIdAndNames(Map map);&#125; 对应 Emp 职员实体类 的映射配置文件 EmpMapper.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--namespace mapper接口 必填 随便填值 防止SQL语句ID重名--&gt;&lt;mapper namespace="com.dao.EmpDao"&gt; &lt;!-- &lt;where&gt; 自动删除第一个 and 或者 or item 表示集合中每一个元素进行迭代时的别名 open 表示该语句以什么开始 separator 表示在每次进行迭代之间以什么符号作为分隔符 close表示以什么结束 如果传入的是单参数且参数类型是一个List的时候，collection属性值为list 如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array 如果传入的参数是多个的时候，就需要把它们封装成一个Map map的key就是参数名--&gt; &lt;delete id="del"&gt; DELETE FROM emp &lt;where&gt; &lt;foreach collection="array" item="eId"&gt; OR id = #&#123;eId&#125; &lt;/foreach&gt; &lt;/where&gt; &lt;/delete&gt; &lt;!--&lt;set&gt; 自动去除最后的逗号 , --&gt; &lt;update id="saveOrUpdate"&gt; &lt;if test="null != id"&gt; UPDATE emp &lt;set&gt; &lt;if test="null != emp_name"&gt; emp_name = #&#123;emp_name&#125;, &lt;/if&gt; &lt;if test="null != depa_id and null != depa_id.id"&gt; depa_id = #&#123;depa_id.id&#125;, &lt;/if&gt; &lt;/set&gt; where id = #&#123;id&#125; &lt;/if&gt; &lt;if test="null == id"&gt; INSERT INTO `emp`(`emp_name`,`depa_id`) VALUES(#&#123;emp_name&#125;,#&#123;depa_id.id&#125;) &lt;/if&gt; &lt;/update&gt; &lt;!--resultType 返回类型 实体类全限定类名--&gt; &lt;select id="getAll" resultMap="EmpMapper"&gt; SELECT * FROM emp e INNER JOIN depa d ON d.`id`=e.`depa_id` INNER JOIN emp_post ep ON ep.`emp_id`=e.`id` INNER JOIN post p ON p.`id`=ep.`post_id` &lt;/select&gt; &lt;!-- prefix 前缀添加什么 prefixOverrides 前缀移除什么 || 为或者 suffix 后缀添加什么 suffixOverrides 后缀移除什么 || 为或者 &lt;trim prefix="WHERE" prefixOverrides="OR || AND"&gt; 等价 &lt;where&gt;--&gt; &lt;select id="getByNames" resultMap="EmpMapper"&gt; SELECT * FROM emp e INNER JOIN depa d ON d.`id`=e.`depa_id` INNER JOIN emp_post ep ON ep.`emp_id`=e.`id` INNER JOIN post p ON p.`id`=ep.`post_id` &lt;trim prefix="WHERE" prefixOverrides="OR || AND"&gt; &lt;foreach collection="list" item="name"&gt; OR e.`emp_name` LIKE CONCAT('%',#&#123;name&#125;,'%') &lt;/foreach&gt; &lt;/trim&gt; &lt;/select&gt; &lt;!-- prefix 前缀添加什么 prefixOverrides 前缀移除什么 || 为或者 suffix 后缀添加什么 suffixOverrides 后缀移除什么 || 为或者 &lt;trim prefix="WHERE" prefixOverrides="OR || AND"&gt; 等价 &lt;where&gt;--&gt; &lt;select id="getByIdAndNames" resultMap="EmpMapper"&gt; SELECT * FROM emp e INNER JOIN depa d ON d.`id`=e.`depa_id` INNER JOIN emp_post ep ON ep.`emp_id`=e.`id` INNER JOIN post p ON p.`id`=ep.`post_id` &lt;trim prefix="WHERE" prefixOverrides="OR|AND"&gt; AND e.`id` = #&#123;mapIdName&#125; AND &lt;/trim&gt; &lt;trim prefixOverrides="OR|AND"&gt; e.`emp_name` IN &lt;foreach collection="mapNameList" item="name" open="(" separator="," close=")"&gt; #&#123;name&#125; &lt;/foreach&gt; &lt;/trim&gt; &lt;/select&gt; &lt;!--type 为resultMap返回类型--&gt; &lt;resultMap id="EmpMapper" type="Emp"&gt; &lt;!--column 为数据库查到后取的别名 property 为type对象对应属性名--&gt; &lt;result column="emp_id" property="id"/&gt; &lt;!--因为数据库的字段与实体类属性名一致--&gt; &lt;!--所以在 mybatis-config.xml 配置 &lt;setting name="autoMappingBehavior" value="FULL"/&gt;--&gt; &lt;!--达到 自动映射行为 : 局部的PARTIAL 重复的 &lt;result/&gt; 可以省略--&gt; &lt;!--&lt;result column="" property=""/&gt;--&gt; &lt;!--联合查询 一对一--&gt; &lt;!--property 为type对象对应属性名 javaType 为所属类型--&gt; &lt;association property="depa_id" javaType="Depa"&gt; &lt;!--column 为数据库查到后取的别名 property 为javaType对象对应属性名--&gt; &lt;result column="depa_id" property="id"/&gt; &lt;!--因为数据库的字段与实体类属性名一致--&gt; &lt;!--所以在 mybatis-config.xml 配置 &lt;setting name="autoMappingBehavior" value="FULL"/&gt;--&gt; &lt;!--达到 自动映射行为 : 全部FULL 重复的 &lt;result/&gt; 可以省略--&gt; &lt;!--&lt;result column="" property=""/&gt;--&gt; &lt;/association&gt; &lt;!--收集 一对多--&gt; &lt;!--property 为type对象对应属性名 javaType 为所属类型--&gt; &lt;collection property="posts" javaType="Post"&gt; &lt;!--column 为数据库查到后取的别名 property 为javaType对象对应属性名--&gt; &lt;result column="post_id" property="id"/&gt; &lt;!--因为数据库的字段与实体类属性名一致--&gt; &lt;!--所以在 mybatis-config.xml 配置 &lt;setting name="autoMappingBehavior" value="FULL"/&gt;--&gt; &lt;!--达到 自动映射行为 : 全部FULL 重复的 &lt;result/&gt; 可以省略--&gt; &lt;!--&lt;result column="" property=""/&gt;--&gt; &lt;/collection&gt; &lt;/resultMap&gt;&lt;/mapper&gt; Post 职位实体类12345678910111213141516171819202122232425262728293031323334353637383940414243package com.entity;import java.util.ArrayList;import java.util.List;public class Post &#123; private Integer id; private String post_name; private List&lt;Emp&gt; emps = new ArrayList&lt;Emp&gt;(); @Override public String toString() &#123; return "Post&#123;" + "id=" + id + ", post_name='" + post_name + '\'' + ", emps=" + emps + '&#125;'; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getPost_name() &#123; return post_name; &#125; public void setPost_name(String post_name) &#123; this.post_name = post_name; &#125; public List&lt;Emp&gt; getEmps() &#123; return emps; &#125; public void setEmps(List&lt;Emp&gt; emps) &#123; this.emps = emps; &#125;&#125; 对应 Post 职位实体类 的实现接口 PostDao 接口类123456789package com.dao;import com.entity.Post;import java.util.List;public interface PostDao &#123; List&lt;Post&gt; getAll();&#125; 对应 Post 职位实体类 的映射配置文件 PostMapper.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--namespace mapper接口 必填 随便填值 防止SQL语句ID重名--&gt;&lt;mapper namespace="com.dao.PostDao"&gt; &lt;!--resultType 返回类型 实体类全限定类名--&gt; &lt;select id="getAll" resultMap="PostMapper"&gt; SELECT * FROM post p INNER JOIN emp_post ep ON ep.`post_id`=p.`id` INNER JOIN emp e ON e.`id`=ep.`emp_id` INNER JOIN depa d ON d.`id`=e.`depa_id` &lt;/select&gt; &lt;!--type 为resultMap返回类型--&gt; &lt;resultMap id="PostMapper" type="Post"&gt; &lt;!--column 为数据库查到后取的别名 property 为type对象对应属性名--&gt; &lt;result column="post_id" property="id"/&gt; &lt;!--因为数据库的字段与实体类属性名一致--&gt; &lt;!--所以在 mybatis-config.xml 配置 &lt;setting name="autoMappingBehavior" value="FULL"/&gt;--&gt; &lt;!--达到 自动映射行为 : 局部的PARTIAL 重复的 &lt;result/&gt; 可以省略--&gt; &lt;!--&lt;result column="" property=""/&gt;--&gt; &lt;!--联合查询 一对一--&gt; &lt;!--property 为type对象对应属性名 javaType 为所属类型--&gt; &lt;association property="emps" javaType="Emp"&gt; &lt;!--column 为数据库查到后取的别名 property 为javaType对象对应属性名--&gt; &lt;result column="emp_id" property="id"/&gt; &lt;!--因为数据库的字段与实体类属性名一致--&gt; &lt;!--所以在 mybatis-config.xml 配置 &lt;setting name="autoMappingBehavior" value="FULL"/&gt;--&gt; &lt;!--达到 自动映射行为 : 全部FULL 重复的 &lt;result/&gt; 可以省略--&gt; &lt;!--&lt;result column="" property=""/&gt;--&gt; &lt;association property="depa_id" javaType="Depa"&gt; &lt;!--column 为数据库查到后取的别名 property 为javaType对象对应属性名--&gt; &lt;result column="depa_id" property="id"/&gt; &lt;!--因为数据库的字段与实体类属性名一致--&gt; &lt;!--所以在 mybatis-config.xml 配置 &lt;setting name="autoMappingBehavior" value="FULL"/&gt;--&gt; &lt;!--达到 自动映射行为 : 全部FULL 重复的 &lt;result/&gt; 可以省略--&gt; &lt;!--&lt;result column="" property=""/&gt;--&gt; &lt;/association&gt; &lt;/association&gt; &lt;/resultMap&gt;&lt;/mapper&gt; mybatis-config.xml MyBatis配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!--可以配置在Java属性配置文件 *.properties 中--&gt; &lt;properties resource=""&gt; &lt;!--可以配置键值对属性在这里而不用配置文件--&gt; &lt;property name="" value=""/&gt; &lt;/properties&gt; &lt;settings&gt; &lt;!-- 打印查询语句 --&gt; &lt;setting name="logImpl" value="STDOUT_LOGGING"/&gt; &lt;!--达到 自动映射行为 : 全部FULL 局部的PARTIAL 禁止自动匹配NONE--&gt; &lt;setting name="autoMappingBehavior" value="FULL"/&gt; &lt;/settings&gt; &lt;!--为Java类型命名一个别名 alias 用于 mappers.xml 的 resultType 直接调用 不用写全限定类名--&gt; &lt;typeAliases&gt; &lt;!--为一个Java类型命名一个别名--&gt; &lt;!--&lt;typeAlias type="" alias=""/&gt;--&gt; &lt;!--为 com.entity 包 全部Java类型命名一个别名 别名为Java类名--&gt; &lt;package name="com.entity"/&gt; &lt;/typeAliases&gt; &lt;!--环境--&gt; &lt;environments default="development"&gt; &lt;!--环境变量--&gt; &lt;environment id="development"&gt; &lt;!--事务管理器--&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!--数据源--&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="simon"/&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;!--MySQL数据库--&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/corp"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--映射器--&gt; &lt;mappers&gt; &lt;!--实体类映射--&gt; &lt;mapper resource="com/entity/DepaMapper.xml"/&gt; &lt;mapper resource="com/entity/EmpMapper.xml"/&gt; &lt;mapper resource="com/entity/PostMapper.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; Test 测试类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.test;import com.dao.DepaDao;import com.dao.EmpDao;import com.dao.PostDao;import com.entity.Depa;import com.entity.Emp;import com.entity.Post;import com.util.MybatisUtil;import org.apache.ibatis.session.SqlSession;import java.util.Arrays;import java.util.HashMap;import java.util.List;import java.util.Map;public class Test &#123; public static void main(String[] args) &#123; SqlSession session = MybatisUtil.getSession(); DepaDao depaDao = session.getMapper(DepaDao.class); EmpDao empDao = session.getMapper(EmpDao.class); PostDao postDao = session.getMapper(PostDao.class); List&lt;Depa&gt; depaDaoAll = depaDao.getAll(); for (Depa depa : depaDaoAll) &#123; System.out.println(depa); &#125; System.out.println("getByNames------三 || 四"); List&lt;Emp&gt; byNames = empDao.getByNames(Arrays.asList("三", "四")); for (Emp emp : byNames) &#123; System.out.println(emp); &#125; Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put("mapIdName", 2); map.put("mapNameList", Arrays.asList("张三", "李四", "王五")); List&lt;Emp&gt; byIdAndNames = empDao.getByIdAndNames(map); System.out.println("byIdAndNames------" + map); for (Emp emp : byIdAndNames) &#123; System.out.println(emp); &#125; Emp simon = new Emp(); simon.setId(1); simon.setEmp_name("Simon"); Depa depa = new Depa(); depa.setId(1); simon.setDepa_id(depa); if (0 == empDao.saveOrUpdate(simon)) System.out.println("saveOrUpdate-----false"); else System.out.println("saveOrUpdate-----true"); Integer del = empDao.del(new Integer[]&#123;2, 3&#125;); if (0 == del) System.out.println("del-----false"); else System.out.println("del-----true"); System.out.println("del-----" + del); List&lt;Emp&gt; empDaoAll = empDao.getAll(); for (Emp emp : empDaoAll) &#123; System.out.println(emp); &#125; List&lt;Post&gt; postDaoAll = postDao.getAll(); for (Post post : postDaoAll) &#123; System.out.println(post); &#125; &#125;&#125; 控制台输出结果mybatis-config.xml 配置 &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt; 控制台会打印执行的SQL语句以及得到的参数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354==&gt; Preparing: SELECT *,e.`id` eId,d.`id` dId FROM depa d INNER JOIN emp e ON d.`id`=e.`depa_id`==&gt; Parameters:&lt;== Columns: id, depa_name, id, emp_name, depa_id, eId, dId&lt;== Row: 1, 销售部, 2, 李四, 1, 2, 1&lt;== Row: 1, 销售部, 3, 王五, 1, 3, 1&lt;== Row: 1, 销售部, 4, 赵六, 1, 4, 1&lt;== Row: 2, 美工部, 1, 张三, 2, 1, 2&lt;== Total: 4Depa&#123;id=1, depa_name=&apos;销售部&apos;, emps=[Emp&#123;id=2, emp_name=&apos;李四&apos;, depa_id=null, posts=[]&#125;, Emp&#123;id=3, emp_name=&apos;王五&apos;, depa_id=null, posts=[]&#125;, Emp&#123;id=4, emp_name=&apos;赵六&apos;, depa_id=null, posts=[]&#125;]&#125;Depa&#123;id=2, depa_name=&apos;美工部&apos;, emps=[Emp&#123;id=1, emp_name=&apos;张三&apos;, depa_id=null, posts=[]&#125;]&#125;getByNames------三 || 四==&gt; Preparing: SELECT * FROM emp e INNER JOIN depa d ON d.`id`=e.`depa_id` INNER JOIN emp_post ep ON ep.`emp_id`=e.`id` INNER JOIN post p ON p.`id`=ep.`post_id` WHERE e.`emp_name` LIKE CONCAT(&apos;%&apos;,?,&apos;%&apos;) OR e.`emp_name` LIKE CONCAT(&apos;%&apos;,?,&apos;%&apos;)==&gt; Parameters: 三(String), 四(String)&lt;== Columns: id, emp_name, depa_id, id, depa_name, emp_id, post_id, id, post_name&lt;== Row: 1, 张三, 2, 2, 美工部, 1, 1, 1, 职员&lt;== Row: 2, 李四, 1, 1, 销售部, 2, 2, 2, 主管&lt;== Row: 1, 张三, 2, 2, 美工部, 1, 4, 4, 部门经理&lt;== Total: 3Emp&#123;id=1, emp_name=&apos;张三&apos;, depa_id=Depa&#123;id=2, depa_name=&apos;美工部&apos;, emps=[]&#125;, posts=[Post&#123;id=1, post_name=&apos;职员&apos;, emps=[]&#125;, Post&#123;id=4, post_name=&apos;部门经理&apos;, emps=[]&#125;]&#125;Emp&#123;id=2, emp_name=&apos;李四&apos;, depa_id=Depa&#123;id=1, depa_name=&apos;销售部&apos;, emps=[]&#125;, posts=[Post&#123;id=2, post_name=&apos;主管&apos;, emps=[]&#125;]&#125;==&gt; Preparing: SELECT * FROM emp e INNER JOIN depa d ON d.`id`=e.`depa_id` INNER JOIN emp_post ep ON ep.`emp_id`=e.`id` INNER JOIN post p ON p.`id`=ep.`post_id` WHERE e.`id` = ? AND e.`emp_name` IN ( ? , ? , ? )==&gt; Parameters: 2(Integer), 张三(String), 李四(String), 王五(String)&lt;== Columns: id, emp_name, depa_id, id, depa_name, emp_id, post_id, id, post_name&lt;== Row: 2, 李四, 1, 1, 销售部, 2, 2, 2, 主管&lt;== Total: 1byIdAndNames------&#123;mapIdName=2, mapNameList=[张三, 李四, 王五]&#125;Emp&#123;id=2, emp_name=&apos;李四&apos;, depa_id=Depa&#123;id=1, depa_name=&apos;销售部&apos;, emps=[]&#125;, posts=[Post&#123;id=2, post_name=&apos;主管&apos;, emps=[]&#125;]&#125;==&gt; Preparing: UPDATE emp SET emp_name = ?, depa_id = ? where id = ?==&gt; Parameters: Simon(String), 1(Integer), 1(Integer)&lt;== Updates: 1saveOrUpdate-----true==&gt; Preparing: DELETE FROM emp WHERE id = ? OR id = ?==&gt; Parameters: 2(Integer), 3(Integer)&lt;== Updates: 2del-----truedel-----2==&gt; Preparing: SELECT * FROM emp e INNER JOIN depa d ON d.`id`=e.`depa_id` INNER JOIN emp_post ep ON ep.`emp_id`=e.`id` INNER JOIN post p ON p.`id`=ep.`post_id`==&gt; Parameters:&lt;== Columns: id, emp_name, depa_id, id, depa_name, emp_id, post_id, id, post_name&lt;== Row: 1, Simon, 1, 1, 销售部, 1, 1, 1, 职员&lt;== Row: 4, 赵六, 1, 1, 销售部, 4, 4, 4, 部门经理&lt;== Row: 1, Simon, 1, 1, 销售部, 1, 4, 4, 部门经理&lt;== Total: 3Emp&#123;id=1, emp_name=&apos;Simon&apos;, depa_id=Depa&#123;id=1, depa_name=&apos;销售部&apos;, emps=[]&#125;, posts=[Post&#123;id=1, post_name=&apos;职员&apos;, emps=[]&#125;, Post&#123;id=4, post_name=&apos;部门经理&apos;, emps=[]&#125;]&#125;Emp&#123;id=4, emp_name=&apos;赵六&apos;, depa_id=Depa&#123;id=1, depa_name=&apos;销售部&apos;, emps=[]&#125;, posts=[Post&#123;id=4, post_name=&apos;部门经理&apos;, emps=[]&#125;]&#125;==&gt; Preparing: SELECT * FROM post p INNER JOIN emp_post ep ON ep.`post_id`=p.`id` INNER JOIN emp e ON e.`id`=ep.`emp_id` INNER JOIN depa d ON d.`id`=e.`depa_id`==&gt; Parameters:&lt;== Columns: id, post_name, emp_id, post_id, id, emp_name, depa_id, id, depa_name&lt;== Row: 1, 职员, 1, 1, 1, Simon, 1, 1, 销售部&lt;== Row: 4, 部门经理, 4, 4, 4, 赵六, 1, 1, 销售部&lt;== Row: 4, 部门经理, 1, 4, 1, Simon, 1, 1, 销售部&lt;== Total: 3Post&#123;id=1, post_name=&apos;职员&apos;, emps=[Emp&#123;id=1, emp_name=&apos;Simon&apos;, depa_id=Depa&#123;id=1, depa_name=&apos;销售部&apos;, emps=[]&#125;, posts=[]&#125;]&#125;Post&#123;id=4, post_name=&apos;部门经理&apos;, emps=[Emp&#123;id=4, emp_name=&apos;赵六&apos;, depa_id=Depa&#123;id=1, depa_name=&apos;销售部&apos;, emps=[]&#125;, posts=[]&#125;, Emp&#123;id=1, emp_name=&apos;Simon&apos;, depa_id=Depa&#123;id=1, depa_name=&apos;销售部&apos;, emps=[]&#125;, posts=[]&#125;]&#125;]]></content>
      <categories>
        <category>MyBatis</category>
        <category>XML</category>
        <category>映射配置</category>
        <category>动态SQL</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>多对多</tag>
        <tag>一对多</tag>
        <tag>多对一</tag>
        <tag>MySQL</tag>
        <tag>MyBatis</tag>
        <tag>一对一</tag>
        <tag>动态SQL</tag>
        <tag>映射配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis框架映射文件配置以及配置文件详解]]></title>
    <url>%2F2018%2F04%2F03%2FMyBatis%E6%A1%86%E6%9E%B6%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[什么是 MyBatis ？MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 MyBatis的 Git 代码库环境idea jdk maven MySQL SMBMS_SQL.sql 创建数据库1234567891011121314151617181920212223-- 创建数据库smbmsCREATE DATABASE smbms;USE smbms;-- 供应商表CREATE TABLE smbms_provider( id INT(20) AUTO_INCREMENT PRIMARY KEY, proCode VARCHAR(20), proName VARCHAR(20), proDesc VARCHAR(50), proContact VARCHAR(20), proPhone VARCHAR(20), proAddress VARCHAR(50), proFax VARCHAR(20), createdBy INT(20), creationDate DATETIME, modifyBy INT(20), modifyDate DATETIME);INSERT INTO `smbms_provider`(`id`,`proCode`,`proName`,`proDesc`,`proContact`,`proPhone`,`proAddress`,`proFax`,`createdBy`,`creationDate`,`modifyDate`,`modifyBy`) VALUES (1,'BJ_GYS001','北京三木堂商贸有限公司','长期合作伙伴，主营产品:茅台、五粮液、郎酒、酒鬼酒、泸州老窖、赖茅酒、法国红酒等','张国强','13566667777','北京市丰台区育芳园北路','010-58858787',1,'2013-03-21 16:52:07',NULL,NULL);INSERT INTO `smbms_provider`(`id`,`proCode`,`proName`,`proDesc`,`proContact`,`proPhone`,`proAddress`,`proFax`,`createdBy`,`creationDate`,`modifyDate`,`modifyBy`) VALUES (2,'HB_GYS001','石家庄帅益食品贸易有限公司','长期合作伙伴，主营产品:饮料、水饮料、植物蛋白饮料、休闲食品、果汁饮料、功能饮料等','王军','13309094212','河北省石家庄新华区','0311-67738876',1,'2016-04-13 04:20:40',NULL,NULL);SELECT * FROM smbms_provider; pom.xml1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com&lt;/groupId&gt; &lt;artifactId&gt;MyBiatisLink&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; MybatisUtil 创建访问数据库得到session对象工具类123456789101112131415161718192021222324252627package com.util;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;public class MybatisUtil &#123; private static SqlSessionFactory sessionFactory; static &#123; try &#123; InputStream inputStream = Resources.getResourceAsStream("mybatis-config.xml"); sessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static SqlSession getSession() &#123; return sessionFactory.openSession(false);//true为自动提交事务 &#125;&#125; Provider 数据库对应的实体类12345678910111213141516171819202122232425262728293031323334353637package com.entity;import java.util.Date;public class Provider &#123; private Integer id; private String proCode; private String proName; private String proDesc; private String proContact; private String proPhone; private String proAddress; private String proFax; private Integer createdBy; private Date creationDate; private Integer modifyBy; private Date modifyDate; @Override public String toString() &#123; return "Provider&#123;" + "id=" + id + ", proCode='" + proCode + '\'' + ", proName='" + proName + '\'' + ", proDesc='" + proDesc + '\'' + ", proContact='" + proContact + '\'' + ", proPhone='" + proPhone + '\'' + ", proAddress='" + proAddress + '\'' + ", proFax='" + proFax + '\'' + ", createdBy=" + createdBy + ", creationDate=" + creationDate + ", modifyBy=" + modifyBy + ", modifyDate=" + modifyDate + '&#125;'; &#125; // 省略getter and setter部分代码&#125; ProviderDao 创建实现访问数据库的接口1234567891011package com.dao;import com.entity.Provider;import java.util.List;public interface ProviderDao &#123; List&lt;Provider&gt; getProviderList(); List&lt;Provider&gt; getProviderByName(Provider provider);&#125; Provider.xml Provider对象与数据库的映射文件配置1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--namespace mapper接口 必填 随便填值 防止SQL语句ID重名--&gt;&lt;mapper namespace="com.dao.ProviderDao"&gt; &lt;!--resultType 返回类型 实体类全限定类名--&gt; &lt;!--为一个Java类型命名一个别名 aliasProvider--&gt; &lt;select id="getProviderList" resultType="aliasProvider"&gt; SELECT * FROM smbms_provider &lt;/select&gt; &lt;!--为 com.entity 包 全部Java类型命名一个别名 别名为Java类名--&gt; &lt;!--ProviderDao 参数为对象 得到对象的属性值方式 #&#123;对象的属性值&#125;--&gt; &lt;select id="getProviderByName" resultType="Provider"&gt; SELECT * FROM smbms_provider WHERE proName LIKE CONCAT('%',#&#123;proName&#125;,'%') &lt;/select&gt;&lt;/mapper&gt; datebase.properties 数据库配置文件有需要可以加上配置文件,或者直接将数据填到 MyBatis上下文配置 mybatis-config.xml 中 123mysqlusername=rootmysqlpassword=simondatebase=smbms mybatis-config.xml 连接数据库的MyBatis上下文配置1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!--可以配置在Java属性配置文件中 用 $&#123;键值&#125;--&gt; &lt;properties resource="datebase.properties"&gt; &lt;!--可以配置键值对属性在这里而不用配置文件--&gt; &lt;property name="mysqldriver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="mysqlurl" value="jdbc:mysql://localhost:3306/"/&gt; &lt;/properties&gt; &lt;settings&gt; &lt;!-- 打印查询语句 --&gt; &lt;setting name="logImpl" value="STDOUT_LOGGING"/&gt; &lt;/settings&gt; &lt;!--为Java类型命名一个别名 alias 用于 mappers.xml 的 resultType 直接调用 不用写全限定类名--&gt; &lt;typeAliases&gt; &lt;!--为一个Java类型命名一个别名--&gt; &lt;typeAlias type="com.entity.Provider" alias="aliasProvider"/&gt; &lt;!--为 com.entity 包 全部Java类型命名一个别名 别名为Java类名--&gt; &lt;package name="com.entity"/&gt; &lt;/typeAliases&gt; &lt;!--环境--&gt; &lt;environments default="development"&gt; &lt;!--环境变量--&gt; &lt;environment id="development"&gt; &lt;!--事务管理器--&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!--数据源--&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="username" value="$&#123;mysqlusername&#125;"/&gt; &lt;property name="password" value="$&#123;mysqlpassword&#125;"/&gt; &lt;property name="driver" value="$&#123;mysqldriver&#125;"/&gt; &lt;!--MySQL数据库--&gt; &lt;property name="url" value="$&#123;mysqlurl&#125;$&#123;datebase&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--映射器--&gt; &lt;mappers&gt; &lt;!--实体类映射--&gt; &lt;mapper resource="com/entity/Provider.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; Test 测试类12345678910111213141516171819202122232425262728293031323334353637383940package com.test;import com.dao.ProviderDao;import com.entity.Provider;import com.util.MybatisUtil;import org.apache.ibatis.session.SqlSession;import java.util.List;public class Test &#123; public static void main(String[] args) &#123; SqlSession session = MybatisUtil.getSession();// 直接去 Mapper.xml 得到数据访问数据库 参数为 namespace.id List&lt;Provider&gt; objects = session.selectList("com.dao.ProviderDao.getProviderList"); for (Provider provider : objects) &#123; System.out.println(provider); &#125; System.out.println("-----------------------------面向对象的方式访问数据库-----------------------------");// 面向对象的方式访问数据库 ProviderDao providerDao = session.getMapper(ProviderDao.class); objects = providerDao.getProviderList(); for (Provider provider : objects) &#123; System.out.println(provider); &#125; System.out.println("-----------------------------ProviderDao接口带参数 实现带参数查询-----------------------------"); Provider p = new Provider(); p.setProName("石"); objects = providerDao.getProviderByName(p); for (Provider provider : objects) &#123; System.out.println(provider); &#125;// 关闭会话 session.close(); &#125;&#125; 点击下载案例]]></content>
      <categories>
        <category>MyBatis</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>关系映射</tag>
        <tag>MySQL</tag>
        <tag>MyBatis</tag>
        <tag>配置文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate 多对多 一对多 多对一 配置解析案例]]></title>
    <url>%2F2017%2F10%2F28%2FHibernate-%E5%A4%9A%E5%AF%B9%E5%A4%9A-%E4%B8%80%E5%AF%B9%E5%A4%9A-%E5%A4%9A%E5%AF%B9%E4%B8%80-%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[此案例用于理解脏检查,以及Hibernate关系映射的配置pom.xml123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com&lt;/groupId&gt; &lt;artifactId&gt;HibernateCase&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;5.2.12.Final&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.hynnet/oracle-driver-ojdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;com.oracle&lt;/groupId&gt; &lt;artifactId&gt;ojdbc6&lt;/artifactId&gt; &lt;version&gt;12.1.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 数据库的关系123456789101112131415161718192021222324--部门CREATE TABLE depa( ID NUMBER NOT NULL, NAME NVARCHAR2 (50) NOT NULL);--职员CREATE TABLE emp( ID NUMBER NOT NULL, NAME NVARCHAR2 (50) NOT NULL, depa_id NUMBER NOT NULL);--职位CREATE TABLE post( ID NUMBER NOT NULL, NAME NVARCHAR2 (50) NOT NULL);--职员职位CREATE TABLE emp_post( emp_id NUMBER NOT NULL, post_id NUMBER NOT NULL); emp_post 职员职位表为中间表,实体类可以不存在 实体类Depa123456789101112131415161718192021222324252627282930313233343536373839404142package com.entity;import java.util.HashSet;import java.util.Set;public class Depa &#123; private Integer id; private String name; private Set&lt;Emp&gt; emps = new HashSet&lt;Emp&gt;(); @Override public String toString() &#123; return "Depa&#123;" + "id=" + id + ", name='" + name + '\'' + '&#125;'; &#125; public Set&lt;Emp&gt; getEmps() &#123; return emps; &#125; public void setEmps(Set&lt;Emp&gt; emps) &#123; this.emps = emps; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; Emp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.entity;import java.util.HashSet;import java.util.Set;public class Emp &#123; private Integer id; private String name; private Depa depaid; private Set&lt;Post&gt; posts = new HashSet&lt;Post&gt;(); @Override public String toString() &#123; return "Emp&#123;" + "id=" + id + ", name='" + name + '\'' + '&#125;'; &#125; public Set&lt;Post&gt; getPosts() &#123; return posts; &#125; public void setPosts(Set&lt;Post&gt; posts) &#123; this.posts = posts; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Depa getDepaid() &#123; return depaid; &#125; public void setDepaid(Depa depaid) &#123; this.depaid = depaid; &#125;&#125; Post123456789101112131415161718192021222324252627282930313233343536373839404142package com.entity;import java.util.HashSet;import java.util.Set;public class Post &#123; private Integer id; private String name; private Set&lt;Emp&gt; emps = new HashSet&lt;Emp&gt;(); @Override public String toString() &#123; return "Post&#123;" + "id=" + id + ", name='" + name + '\'' + '&#125;'; &#125; public Set&lt;Emp&gt; getEmps() &#123; return emps; &#125; public void setEmps(Set&lt;Emp&gt; emps) &#123; this.emps = emps; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; Emp 实体类 和 Post 实体类 都有对方的 Set&lt;?&gt; 集合,这也是操作中间表 emp_post 的关键属性 对实体类关系映射配置depa.hbm.xml123456789101112131415161718192021&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping package="com.entity"&gt; &lt;class name="Depa" table="depa"&gt; &lt;id name="id"&gt; &lt;generator class="increment"/&gt; &lt;/id&gt; &lt;property name="name"/&gt; &lt;!--一对多 name为实体类属性名 class为对应外键对应实体类--&gt; &lt;!--table 实体类对象数据来源数据库表名 cascade维护方式--&gt; &lt;!--inverse 指定由哪一方来维护之间的关联关系 当一方中指定了"inverse=false"(默认),那么那一方就有责任负责之间的关联关系--&gt; &lt;set name="emps" table="emp" cascade="all" inverse="true"&gt; &lt;!--column 为emp数据库关联depa的外键名--&gt; &lt;key column="depa_id"&gt;&lt;/key&gt; &lt;!--class emps的单个实体数据为哪个实体类--&gt; &lt;one-to-many class="Emp"/&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; emp.hbm.xml1234567891011121314151617181920212223242526&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;!--package为命名空间 子节点有多个类的全在com.entity包里--&gt;&lt;!--(如果不写,下面 &lt;class name="Emp" name值"Emp"需要改成"com.entity.Emp")--&gt;&lt;hibernate-mapping package="com.entity"&gt; &lt;class name="Emp" table="emp"&gt; &lt;!--主键--&gt; &lt;id name="id"&gt; &lt;!--自增方式--&gt; &lt;generator class="increment"/&gt; &lt;/id&gt; &lt;!--普通数据列--&gt; &lt;property name="name"/&gt; &lt;!--多对一 name为实体类属性名 class为对应外键对应实体类 column为数据库外键名(如果与name值一样可以忽略)--&gt; &lt;many-to-one name="depaid" class="Depa" column="depa_id"/&gt; &lt;!--多对多 name为实体类属性名 table 关联的中间表 cascade 维护方式 save-update 为维护方式是新增或修改--&gt; &lt;set name="posts" table="emp_post" cascade="save-update"&gt; &lt;!--中间表emp_post 对应emp的外键--&gt; &lt;key column="emp_id"&gt;&lt;/key&gt; &lt;!--class 多对多的实体类 column 中间表emp_post 对应Post的外键--&gt; &lt;many-to-many class="Post" column="post_id"/&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; post.hbm.xml12345678910111213141516171819&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping package="com.entity"&gt; &lt;class name="Post" table="post"&gt; &lt;id name="id"&gt; &lt;generator class="increment"/&gt; &lt;/id&gt; &lt;property name="name"/&gt; &lt;!--多对多 name为实体类属性名 table 关联的中间表 cascade 维护方式 save-update 为维护方式是新增或修改--&gt; &lt;set name="emps" table="emp_post" cascade="save-update"&gt; &lt;!--中间表emp_post 对应post的外键--&gt; &lt;key column="post_id"&gt;&lt;/key&gt; &lt;!--class 多对多的实体类 column 中间表emp_post 对应Emp的外键--&gt; &lt;many-to-many class="Emp" column="emp_id"/&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 将实体类的 XML 映射到 hibernate.cfg.xml 配置 hibernate.cfg.xml12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;property name="connection.url"&gt;jdbc:oracle:thin:@localhost:1521:orcl&lt;/property&gt; &lt;property name="connection.username"&gt;system&lt;/property&gt; &lt;property name="connection.password"&gt;simon&lt;/property&gt; &lt;property name="connection.driver_class"&gt;oracle.jdbc.driver.OracleDriver&lt;/property&gt; &lt;property name="current_session_context_class"&gt;thread&lt;/property&gt; &lt;property name="show_sql"&gt;true&lt;/property&gt; &lt;property name="format_sql"&gt;true&lt;/property&gt; &lt;mapping resource="com/entity/depa.hbm.xml"/&gt; &lt;mapping resource="com/entity/emp.hbm.xml"/&gt; &lt;mapping resource="com/entity/post.hbm.xml"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; Hibernate工具类 HibernateUtil12345678910111213141516171819package com.util;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.cfg.Configuration;public class HibernateUtil &#123; private static Configuration configuration; private static final SessionFactory factory; static &#123; configuration = new Configuration().configure("hibernate.cfg.xml"); factory = configuration.buildSessionFactory(); &#125; public static Session getSession() &#123; return factory.getCurrentSession(); &#125;&#125; 测试类 Test123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.test;import com.entity.Depa;import com.entity.Emp;import com.entity.Post;import com.util.HibernateUtil;import org.hibernate.Session;import org.hibernate.Transaction;public class Test &#123; public static void main(String[] args) &#123; Session session = HibernateUtil.getSession(); Transaction transaction = session.beginTransaction(); System.out.println("查询ID为1的职员数据"); Emp emp = session.get(Emp.class, 1); System.out.println(emp); System.out.println("通过职员得到中间表emp_post数据"); for (Post post : emp.getPosts()) &#123; System.out.println(post); &#125; System.out.println("清除职员中间表emp_post的数据"); emp.getPosts().clear(); System.out.println("查询ID为2的职位数据"); Post post = session.get(Post.class, 2); System.out.println(post); System.out.println("将查到的职位给职员新增中间表emp_post数据"); emp.getPosts().add(post); System.out.println("查询ID为1的职员数据"); emp = session.get(Emp.class, 1); System.out.println(emp); System.out.println("通过职员得到中间表emp_post数据"); for (Post temp : emp.getPosts()) &#123; System.out.println(temp); &#125; System.out.println("通过职员得到部门表depa数据"); System.out.println(emp.getDepaid()); System.out.println("查询ID为1的部门数据"); Depa depa = session.get(Depa.class, 1); System.out.println(depa); System.out.println("将查到的部门depa给职员emp利用脏检查修改"); emp.setDepaid(depa); System.out.println("查询ID为1的职员数据"); emp = session.get(Emp.class, 1); System.out.println(emp); System.out.println("通过职员得到部门表depa数据"); System.out.println(emp.getDepaid()); System.out.println("查询ID为2的部门数据"); depa = session.get(Depa.class, 2); System.out.println(depa); System.out.println("得到部门对象所属职员"); for (Emp e : depa.getEmps()) &#123; System.out.println(e); &#125; System.out.println("利用脏检查删除部门对象所属的ID为1的职员"); depa.getEmps().remove(emp); System.out.println("查询ID为2的部门数据"); depa = session.get(Depa.class, 2); System.out.println(depa); System.out.println("得到部门对象所属职员"); for (Emp e : depa.getEmps()) &#123; System.out.println(e); &#125; //不提交,则上面的结果不会对数据库执行操作// transaction.commit(); &#125;&#125; 控制台输出看看测试类代码对数据库的数据进行了哪些操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586查询ID为1的职员数据Hibernate: select emp0_.id as id1_1_0_, emp0_.name as name2_1_0_, emp0_.depa_id as depa_id3_1_0_ from emp emp0_ where emp0_.id=?Emp&#123;id=1, name=&apos;张三&apos;&#125;通过职员得到中间表emp_post数据Hibernate: select posts0_.emp_id as emp_id1_2_0_, posts0_.post_id as post_id2_2_0_, post1_.id as id1_3_1_, post1_.name as name2_3_1_ from emp_post posts0_ inner join post post1_ on posts0_.post_id=post1_.id where posts0_.emp_id=?Post&#123;id=1, name=&apos;职员&apos;&#125;清除职员中间表emp_post的数据查询ID为2的职位数据Hibernate: select post0_.id as id1_3_0_, post0_.name as name2_3_0_ from post post0_ where post0_.id=?Post&#123;id=2, name=&apos;主管&apos;&#125;将查到的职位给职员新增中间表emp_post数据查询ID为1的职员数据Emp&#123;id=1, name=&apos;张三&apos;&#125;通过职员得到中间表emp_post数据Post&#123;id=2, name=&apos;主管&apos;&#125;通过职员得到部门表depa数据Hibernate: select depa0_.id as id1_0_0_, depa0_.name as name2_0_0_ from depa depa0_ where depa0_.id=?Depa&#123;id=2, name=&apos;美工部&apos;&#125;查询ID为1的部门数据Hibernate: select depa0_.id as id1_0_0_, depa0_.name as name2_0_0_ from depa depa0_ where depa0_.id=?Depa&#123;id=1, name=&apos;销售部&apos;&#125;将查到的部门depa给职员emp利用脏检查修改查询ID为1的职员数据Emp&#123;id=1, name=&apos;张三&apos;&#125;通过职员得到部门表depa数据Depa&#123;id=1, name=&apos;销售部&apos;&#125;查询ID为2的部门数据Depa&#123;id=2, name=&apos;美工部&apos;&#125;得到部门对象所属职员Hibernate: select emps0_.depa_id as depa_id3_1_0_, emps0_.id as id1_1_0_, emps0_.id as id1_1_1_, emps0_.name as name2_1_1_, emps0_.depa_id as depa_id3_1_1_ from emp emps0_ where emps0_.depa_id=?Emp&#123;id=1, name=&apos;张三&apos;&#125;利用脏检查删除部门对象所属的ID为1的职员查询ID为2的部门数据Depa&#123;id=2, name=&apos;美工部&apos;&#125;得到部门对象所属职员 点击下载案例]]></content>
      <categories>
        <category>Hibernate</category>
        <category>关系映射</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
        <tag>idea</tag>
        <tag>Oracle</tag>
        <tag>多对多</tag>
        <tag>一对多</tag>
        <tag>多对一</tag>
        <tag>many-to-many</tag>
        <tag>many-to-one</tag>
        <tag>one-to-many</tag>
        <tag>关系映射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate 主键 ID 生成方式]]></title>
    <url>%2F2017%2F09%2F28%2FHibernate-%E4%B8%BB%E9%94%AE-ID-%E7%94%9F%E6%88%90%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[ID生成方式序列sequence 只适用于Oracle12345&lt;id name="id" column="id"&gt; &lt;generator class="sequence"&gt; &lt;param name="sequence"&gt;person_seq&lt;/param&gt;&lt;!--指定sequence名--&gt; &lt;/generator&gt;&lt;/id&gt; 自增列，适用于SQLServer、MySql123&lt;id name="id" column="id"&gt; &lt;generator class="identity"/&gt;&lt;/id&gt; 取最大值加一 max()+1123&lt;id name="id" column="id" type="integer"&gt; &lt;generator class="increment"/&gt;&lt;/id&gt; 根据底层数据库指定生成方法123&lt;id name="id" column="id"&gt; &lt;generator class="native"/&gt;&lt;/id&gt; 使用缺省策略针对Oracle数据库的生成方式还是sequence，只不过需要一个特定名字的sequence，”hibernate_sequence”。 高低位算法12345678910&lt;id name="id" column="id"&gt; &lt;generator class="hilo"&gt; &lt;param name="table"&gt;high_value&lt;/param&gt; &lt;!--设置高位值取值的表--&gt; &lt;param name="column"&gt;next_value&lt;/param&gt; &lt;!--设置高位值取值的字段--&gt; &lt;param name="max_lo"&gt;50&lt;/param&gt; &lt;!--指定低位最大值，当取道最大值是会再取一个高位值再运算--&gt; &lt;/generator&gt;&lt;/id&gt; Oracle数据库注解 sequence 数据库序列定义12345@SequenceGenerator(name = "sequenceInfo", sequenceName = "SEQ_name")@GeneratedValue(generator = "sequenceInfo")@Id@Columnprivate Integer id; SEQ_name 为Oracle数据库序列名 Oracle数据库XML sequence 数据库序列定义12345678910111213&lt;!--package为命名空间 子节点有多个类的全在com.entity包里--&gt;&lt;!--(如果不写,下面 &lt;class name="Emp" name值"Emp"需要改成全限定类名(绝对路径)"com.entity.Emp")--&gt;&lt;hibernate-mapping package="com.entity"&gt; &lt;class name="Emp" table="emp"&gt; &lt;!--主键--&gt; &lt;id name="id"&gt; &lt;!--自增方式--&gt; &lt;generator class="sequence"&gt; &lt;param name="sequence"&gt;SEQ_name&lt;/param&gt; &lt;/generator&gt; &lt;/id&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt;]]></content>
      <categories>
        <category>Hibernate</category>
        <category>XML</category>
        <category>主键</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
        <tag>主键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中继承与多态实例]]></title>
    <url>%2F2017%2F07%2F04%2FJava%E4%B8%AD%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[继承的概念继承是面向对象最显著的一个特性。继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。子类又被称为派生类； 父类又被称为超类（Super Class）。一个子类只能够继承一个父类，存在单继承局限。 在一个子类继承的时候，实际上会继承父类之中的所有操作（属性、方法），但是需要注意的是，对于所有的非私有（no private）操作属于显式继承（可以直接利用对象操作），而所有的私有操作属于隐式继承（间接完成）。在继承关系之中，如果要实例化子类对象，会默认先调用父类构造，为父类之中的属性初始化，之后再调用子类构造，为子类之中的属性初始化，即：默认情况下，子类会找到父类之中的无参构造方法。 用于理解的demo1234567891011121314151617181920212223242526272829303132333435363738394041424344class A &#123; public String show(D obj) &#123; return ("A and D"); &#125; public String show(A obj) &#123; return ("A and A"); &#125;&#125;class B extends A &#123; public String show(B obj) &#123; return ("B and B"); &#125; public String show(A obj) &#123; return ("B and A"); &#125;&#125;class C extends B &#123;&#125;class D extends B &#123;&#125;public class Test &#123; public static void main(String[] args) &#123; A a1 = new A(); A a2 = new B(); B b = new B(); C c = new C(); D d = new D(); System.out.println("1--" + a1.show(b)); System.out.println("2--" + a1.show(c)); System.out.println("3--" + a1.show(d)); System.out.println("4--" + a2.show(b)); System.out.println("5--" + a2.show(c)); System.out.println("6--" + a2.show(d)); System.out.println("7--" + b.show(b)); System.out.println("8--" + b.show(c)); System.out.println("9--" + b.show(d)); &#125;&#125; 控制台输出结果1234567891--A and A2--A and A3--A and D4--B and A5--B and A6--A and D7--B and B8--B and B9--A and D]]></content>
      <categories>
        <category>Java</category>
        <category>extends</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>继承</tag>
        <tag>多态</tag>
        <tag>extends</tag>
        <tag>重写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2如何在Action与JSP之间传值]]></title>
    <url>%2F2017%2F06%2F29%2FStruts2%E5%A6%82%E4%BD%95%E5%9C%A8Action%E4%B8%8EJSP%E4%B9%8B%E9%97%B4%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[struts2中Action到底是什么，怎么理解问题描述struts2中Action到底是什么，怎么理解1.配置完web.xml2.创建视图页面login.jsp3.创建业务控制器LoginAction类（解释说：创建业务控制器LoginAction类，该类为程序的Action类）4.配置LoginAction类（解释说：当Action处理完客户端请求后返回一个字符串，没个字符串对应一个视图） 那么这个Action到底是什么，是一个类吗？怎么理解它，它和用于标签的有什么区别。 解决方案首先，你了解Servlet么？Servlet是运行在java服务器端的java代码，这个Action本质就是Servlet啊。它作为java web应用的控制层，它完成浏览器的请求后返回一个页面给客户端浏览器。其次，action的处理流程是由strut2的中央控制器完成的，Action处理完客户端请求后返回一个字符串，每个字符串对应一个视图，也就是说它处理浏览器的请求的过程，返回的视图本质就是jsp页面。结论就是：action的本质就是Servlet。 Struts2如何在Action与JSP之间传值pom.xml12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;ActionValueOf&lt;/name&gt; &lt;groupId&gt;com&lt;/groupId&gt; &lt;artifactId&gt;ActionValueOf&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.struts/struts2-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.struts&lt;/groupId&gt; &lt;artifactId&gt;struts2-core&lt;/artifactId&gt; &lt;version&gt;2.3.16.3&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; User 用户实体类12345678910111213141516171819202122package entity;public class User &#123; private String username; private String password; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; InfoAction12345678910111213141516package action;import com.opensymphony.xwork2.ActionSupport;import entity.User;public class InfoAction extends ActionSupport &#123; private User user = new User(); public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125;&#125; index.jspindex.jsp 只用于打开页面时先进入 action 12345678910&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%--meta标签在 index.jsp 打开后跳转到指定的 action--%&gt;&lt;meta http-equiv="refresh" content="0; url=info.action"/&gt;&lt;/body&gt;&lt;/html&gt; info.jspinfo.jsp 用一个页面来实现与 action 的相互传值,其中用 OGNL 来提取 action 实体类的值 1234567891011121314151617181920&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;%@ taglib prefix="s" uri="/struts-tags" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type="text/javascript"&gt; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form method="post" action="info.action"&gt; 用户名 : &lt;input type="text" name="user.username" value="&lt;s:property value="user.username"/&gt;"/&gt; 密 码 : &lt;input type="password" name="user.password" value="&lt;s:property value="user.password"/&gt;"/&gt; &lt;input type="submit" value="提交"/&gt;&lt;/form&gt;&lt;a href="info.action?user.username=Simon&amp;user.password=password"&gt;利用script get方式进入action&lt;/a&gt;&lt;h1&gt;用户名 : &lt;s:property value="user.username"/&gt;&lt;/h1&gt;&lt;h1&gt;密 码 : &lt;s:property value="user.password"/&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; struts.xml 配置文件12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN" "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;&lt;struts&gt; &lt;package name="default" extends="struts-default"&gt; &lt;action name="info" class="action.InfoAction" method="execute"&gt; &lt;result&gt;info.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; web.xml 配置123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app version="2.4" xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"&gt; &lt;filter&gt; &lt;filter-name&gt;struts&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; 点击下载案例]]></content>
      <categories>
        <category>Struts2</category>
        <category>Action</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>OGNL</tag>
        <tag>Struts2</tag>
        <tag>Action</tag>
        <tag>传值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate主键自增长increment]]></title>
    <url>%2F2017%2F06%2F18%2FHibernate%E4%B8%BB%E9%94%AE%E8%87%AA%E5%A2%9E%E9%95%BFincrement%2F</url>
    <content type="text"><![CDATA[increment由Hibernate从数据库中取出主键的最大值（每个session只取1次），以该值为基础，每次增量为1，在内存中生成主键，不依赖于底层的数据库，因此可以跨数据库。 123&lt;id name="id" column="id"&gt; &lt;generator class="increment" /&gt;&lt;/id&gt; Hibernate调用org.hibernate.id.IncrementGenerator类里面的generate()方法，使用select max(idColumnName) from tableName语句获取主键最大值。 以上为 XML 配置自增长，而使用 注解 的方式就需要一下的步骤实现： 12345@GenericGenerator(name = "generator", strategy = "increment")@GeneratedValue(generator = "generator")@Id@Columnprivate Integer id;]]></content>
      <categories>
        <category>Hibernate</category>
        <category>increment</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
        <tag>increment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2拦截器实现用户访问控制]]></title>
    <url>%2F2017%2F06%2F14%2FStruts2%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[拦截器 Interceptorjava里的拦截器是动态拦截Action调用的对象。它提供了一种机制可以使开发者可以定义在一个action执行的前后执行的代码，也可以在一个action执行前阻止其执行，同时也提供了一种可以提取action中可重用部分的方式。在AOP（Aspect-Oriented Programming）中拦截器用于在某个方法或字段被访问之前，进行拦截然后在之前或之后加入某些操作。 自定义拦截器自定义一个实现Interceptor接口（或者继承自AbstractInterceptor）的类。在struts.xml中注册上一步中定义的拦截器。在需要使用的Action中引用上述定义的拦截器，为了方便也可将拦截器定义为默认的拦截器，这样在不加特殊声明的情况下所有的Action都被这个拦截器拦截。与过滤器的区别过滤器可以简单理解为“取你所想取”，忽视掉那些你不想要的东西；拦截器可以简单理解为“拒你所想拒”，关心你想要拒绝掉哪些东西，比如一个BBS论坛上拦截掉敏感词汇。 拦截器是基于java反射机制的，而过滤器是基于函数回调的。过滤器依赖于servlet容器，而拦截器不依赖于servlet容器。拦截器只对action起作用，而过滤器几乎可以对所有请求起作用。拦截器可以访问action上下文、值栈里的对象，而过滤器不能。在action的生命周期里，拦截器可以多起调用，而过滤器只能在容器初始化时调用一次。关键代码12345678910111213141516171819package com.interceptor;import com.opensymphony.xwork2.ActionInvocation;import com.opensymphony.xwork2.interceptor.AbstractInterceptor;public class LoginInterceptor extends AbstractInterceptor &#123; public String intercept(ActionInvocation actionInvocation) throws Exception &#123; //得到session key为users 的数据 Object users = actionInvocation.getInvocationContext().getSession().get("users"); String name = actionInvocation.getInvocationContext().getName(); //得到访问action 的名字 login.action 得到 login System.out.println(name); //第一次登录时users 肯定为空,如果登录时找不到users 应该给它通过拦截器 if (null != users || "login".equals(name)) //继续执行剩余的拦截器和action return actionInvocation.invoke(); return "login"; &#125;&#125; struts.xml 拦截器配置1234567891011121314&lt;struts&gt; &lt;package name="default" extends="struts-default"&gt; &lt;interceptors&gt; &lt;!--定义权限验证拦截器--&gt; &lt;interceptor name="sessionUser" class="com.interceptor.LoginInterceptor"&gt;&lt;/interceptor&gt; &lt;interceptor-stack name="LoginFlag"&gt; &lt;interceptor-ref name="sessionUser"/&gt; &lt;interceptor-ref name="defaultStack"/&gt; &lt;/interceptor-stack&gt; &lt;/interceptors&gt; &lt;!--定义默认拦截器--&gt; &lt;default-interceptor-ref name="LoginFlag"/&gt; &lt;/package&gt;&lt;/struts&gt; 其中可以看到有一行配置 &lt;interceptor-ref name=&quot;defaultStack&quot;/&gt; defaultStack该拦截器用于实现数据的传输，如果不写的话会出现数据提取不到]]></content>
      <categories>
        <category>Struts2</category>
        <category>idea</category>
        <category>Interceptor</category>
        <category>AbstractInterceptor</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>Struts2</tag>
        <tag>拦截器</tag>
        <tag>Interceptor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OGNL创建和配置自定义日期类型转换器]]></title>
    <url>%2F2017%2F06%2F12%2FOGNL%E5%88%9B%E5%BB%BA%E5%92%8C%E9%85%8D%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%A5%E6%9C%9F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%99%A8%2F</url>
    <content type="text"><![CDATA[OGNLOGNL 中文名 对象图导航语言 是 Object-Graph Navigation Language 的缩写，它是一种功能强大的表达式语言，通过它简单一致的表达式语法，可以存取对象的任意属性，调用对象的方法，遍历整个对象的结构图，实现字段类型转化等功能。它使用相同的表达式去存取对象的属性。 基于OGNL的类型转换器Struts2的类型转换器都需要实现一个TypeConverter接口，该接口位于ognl.jar包内，也是就Struts2框架的转换器使用了OGNL技术。该接口定义了一个convertValue()方法，实现该接口的类型转换器实现类都需要重写该方法来进行类型转换。OGNL还提供了一个实现TypeConverter接口的类DefaultTypeConverter，开发者只要继承该类，就可以开发类型转换器的实现类。 DefaultTypeConverter类的子类需要重写convertValue()方法，来实现字符串类型与复合类型之间的双向转换。convertValue()方法有三个参数：Map context：该参数为类型转换环境的上下文内容；Object value：该参数为需要转换的参数；Class toType：该参数指的是转换目标的类型。 123456789101112131415161718public class PointConverter extends DefaultTypeConverter &#123; public Object convertValue(Map context,Object value,Class toType)&#123; System.out.println("正在转换..."); if(toType==Point.class)&#123; String[] p=(String[])value; Point point=new Point(); String[] pp=p[0].split(","); point.setX(pp[0]); point.setY(pp[1]); return point; &#125; else if(toType==String.class)&#123; Point point=(Point) value; return "&lt;"+point.getX()+","+point.getY()+"&gt;"; &#125; return null; &#125;&#125; convertValue()方法是通过toType的类型判断来实现双向转换的 基于Struts2的类型转换器Struts2框架提供了一个类型转换器的StrutsTypeConverter抽象类，开发者可以继承该类来开发自定义的类型转换器实现类。 该抽象类实际上继承了DefaultTypeConverter类，在该类的基础上进行了简化。StrutsTypeConverter抽象类是Struts2框架中类型转换器的基础，该类中提供了两个抽象方法，这两个抽象方法分别实现“form字符串参数-Struts复合类型”之间的双向转换 123456789101112131415161718192021public class PointConverter2 extends StrutsTypeConverter &#123; //定义convertFromString方法 @Override public Object convertFromString(Map arg0, String[] arg1, Class arg2) &#123; // TODO Auto-generated method stub System.out.println("正在转换：从字符串转换到复合类型..."); Point point=new Point(); String[] pp=arg1[0].split(","); point.setX(pp[0]); point.setY(pp[1]); return point; &#125; //定义convertToString方法 @Override public String convertToString(Map arg0, Object arg1) &#123; // TODO Auto-generated method stub Point point=(Point) arg1; return "&lt;"+point.getX()+","+point.getY()+"&gt;"; &#125;&#125; 自定义日期类型转换器例子环境idea Java Maven Struts2 Tomcat pom.xml 配置 dependencies12345678&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.struts/struts2-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.struts&lt;/groupId&gt; &lt;artifactId&gt;struts2-core&lt;/artifactId&gt; &lt;version&gt;2.3.16.3&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; util包 DateConverter类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.util;import com.opensymphony.xwork2.conversion.TypeConversionException;import org.apache.struts2.util.StrutsTypeConverter;import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;import java.util.Map;public class DateConverter extends StrutsTypeConverter &#123; //支持转换的多种日期格式,可增加时间格式 private final DateFormat[] dfs = &#123; new SimpleDateFormat("yyyy年MM月dd日"), new SimpleDateFormat("yyyy/MM/dd"), new SimpleDateFormat("yyyy-MM-dd"), new SimpleDateFormat("yyyy@MM@dd") &#125;; /** * 将指定格式字符串转换为日期类型 * * @param map 类型转换环境的上下文内容 * @param strings 需要转换的参数 * @param aClass 转换目标的类型 * @return */ public Object convertFromString(Map map, String[] strings, Class aClass) &#123; String dateStr = strings[0]; //获取日期的字符串 for (int i = 0; i &lt; dfs.length; i++) &#123; //遍历日期支持格式,进行转换 try &#123; return dfs[i].parse(dateStr); &#125; catch (Exception e) &#123; continue; &#125; &#125; //如果遍历完毕后仍没有转换成功,表明出现转换异常 throw new TypeConversionException(); &#125; /** * 将日期转换为指定格式字符串 * * @param map * @param o * @return */ public String convertToString(Map map, Object o) &#123; Date date = (Date) o; //输出的格式是yyyy-MM-dd return new SimpleDateFormat("yyyy-MM-dd").format(date); &#125;&#125; action包 DateAction类1234567891011121314151617181920212223package com.action;import com.opensymphony.xwork2.ActionSupport;import com.opensymphony.xwork2.ValidationAware;import java.util.Date;public class DateAction extends ActionSupport implements ValidationAware &#123; public Date getTime() &#123; return time; &#125; public void setTime(Date time) &#123; this.time = time; &#125; private Date time; @Override public String execute() throws Exception &#123; return SUCCESS; &#125;&#125; xwork-conversion.properties 配置转换类全名=类型转换器类全名 1java.util.Date=com.util.DateConverter 测试页面 index.jsp12345678910111213141516&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;%@taglib prefix="s" uri="/struts-tags" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="format.action" method="post"&gt; 日期类型转换器: &lt;input type="text" name="time" value="1993@12@24"/&gt; &lt;input type="submit" value="提交"/&gt;&lt;/form&gt;&lt;s:property value="time"/&gt;&lt;s:fielderror/&gt;&lt;/body&gt;&lt;/html&gt; web.xml 配置1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app version="2.4" xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;filter&gt; &lt;filter-name&gt;Struts&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;Struts&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; struts.xml 配置12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN" "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;&lt;struts&gt; &lt;!--value 的 message 为指定根目录的 message.properties 配置文件--&gt; &lt;constant name="struts.custom.i18n.resources" value="message"/&gt; &lt;package name="default" extends="struts-default"&gt; &lt;action name="format" class="com.action.DateAction"&gt; &lt;result&gt;index.jsp&lt;/result&gt; &lt;result name="input"&gt;index.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; message.properties 修改错误信息配置1xwork.default.invalid.fieldvalue=\u5b57\u6bb5&quot;&#123;0&#125;&quot;\u7684\u503c\u65e0\u6548 `\u5b57\u6bb5&quot;{0}&quot;\u7684\u503c\u65e0\u6548` 为 Unicode编码 `字段&quot;{0}&quot;的值无效` 配置文件 `中文` 需要转换成 `Unicode编码` Unicode编码转换网站 项目结构 演示效果初始页面 转换成功 转换失败]]></content>
      <categories>
        <category>Struts2</category>
        <category>OGNL</category>
        <category>自定义转换器</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>Java</tag>
        <tag>OGNL</tag>
        <tag>自定义转换器</tag>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2的配置和一个简单的例子]]></title>
    <url>%2F2017%2F06%2F07%2FStruts2%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90%2F</url>
    <content type="text"><![CDATA[环境idea tomcat jdk maven 步骤pom.xml 配置 Struts2点击前往获取自己想要的版本对应的XML 123456789&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.struts/struts2-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.struts&lt;/groupId&gt; &lt;artifactId&gt;struts2-core&lt;/artifactId&gt; &lt;version&gt;2.3.16.3&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建 User 类 用于展现提取对象的数据12345678910111213141516171819202122package com.entity;public class User &#123; private String username; private String password; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; 创建 LoginAction 类 代替以往的 servlet 层12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.action;import com.entity.User;import com.opensymphony.xwork2.Action;import com.opensymphony.xwork2.ActionContext;import com.opensymphony.xwork2.ActionSupport;import java.util.Map;//继承 ActionSupport 用于实现 servlet层 数据校验public class LoginAction extends ActionSupport implements Action &#123; //接收页面提交数据 属性名 为 input 标签 name 属性 private String username; private String password; //提供 get set 接收页面的数据 get 为提取 set 为接收 public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; //实现Action 的方法 为 struts.xml action 标签 method=""的默认方法入口 可以不写该属性 public String execute() throws Exception &#123; return null; &#125; //用于实现 servlet层 数据校验 //在页面跳转到login 方法前会先进来这里面 @Override public void validate() &#123; if(username.length()==0 || password.length()==0)&#123; //如果在validate 方法里面 调用addFieldError 则后面不进入 login 方法 并如同login 默认返回 Action 接口提供的INPUT常量字符串 addFieldError("username","用户名不能为空"); addFieldError("password","密码不能为空"); &#125; &#125; //自定义入口 login public String login() &#123; User user = new User(); user.setUsername("simon"); user.setPassword("simon"); //得到上下文对象 ActionContext context = ActionContext.getContext(); //得到request对象 Map&lt;String, Object&gt; request = (Map&lt;String, Object&gt;) context.get("request"); //得到session对象 Map&lt;String, Object&gt; session = context.getSession(); //得到application对象 Map&lt;String, Object&gt; application = context.getApplication(); if (user.getUsername().equals(getUsername()) &amp;&amp; user.getPassword().equals(getPassword())) &#123; //登录成功存一个User对象 session.put("user", user); //使用自定义字符串返回 success Action 接口提供的常量为 SUCCESS return "success"; &#125; //定义errorinfo 错误信息到request request.put("errorinfo", "登录失败"); //使用Action 接口提供的常量字符串 return ERROR; &#125;&#125; 创建页面 index.jsp1234567891011121314151617181920212223&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;%@taglib prefix="s" uri="/struts-tags" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%--从request里面找errorinfo的数据--%&gt;&lt;h1&gt;$&#123;requestScope.errorinfo&#125;&lt;/h1&gt;&lt;%--显示全部 fielderror 错误信息--%&gt;&lt;h1&gt;&lt;s:fielderror/&gt;&lt;/h1&gt;&lt;%--显示某个 fielderror 错误信息--%&gt;&lt;h1&gt;&lt;s:fielderror fieldName="password"/&gt;&lt;/h1&gt;&lt;hr/&gt;&lt;%--Login 为 struts.xml 定义 action name 的名称 .action 为 Struts 标识--%&gt;&lt;form action="Login.action" method="post"&gt; &lt;%--name属性要和LoginAction对象的属性一致--%&gt; 用户名: &lt;input type="text" name="username"/&gt;&lt;br/&gt; 密 码: &lt;input type="password" name="password"/&gt;&lt;br/&gt; &lt;input type="submit" value="登录"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 创建页面 success.jsp1234567891011121314&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;%@taglib prefix="s" uri="/struts-tags" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;登录成功&lt;/h1&gt;&lt;h2&gt;欢迎您，&lt;s:property value="username"/&gt;&lt;/h2&gt;&lt;h1&gt;session对象的User对象数据&lt;/h1&gt;&lt;h2&gt;用户名: $&#123;sessionScope.user.username&#125;&lt;/h2&gt;&lt;h2&gt;密 码: $&#123;sessionScope.user.password&#125;&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 配置 web.xml 文件123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app version="2.4" xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; 配置 struts.xml 文件12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN" "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;&lt;struts&gt; &lt;package name="default" extends="struts-default"&gt; &lt;!--method 默认值为execute 也可以自定义login方法--&gt; &lt;action name="Login" class="com.action.LoginAction" method="login"&gt; &lt;!--表示程序处理正常，并返回给用户成功后的结果--&gt; &lt;result name="success"&gt;success.jsp&lt;/result&gt; &lt;!--表示处理结果失败--&gt; &lt;result name="error"&gt;index.jsp&lt;/result&gt; &lt;!--表示数据校验处理失败--&gt; &lt;result name="input"&gt;index.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 项目结构 参考网址Struts2官方文档]]></content>
      <categories>
        <category>Struts2</category>
        <category>idea</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>Struts2</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate中的mappedBy和注解@JoinColumn]]></title>
    <url>%2F2017%2F06%2F06%2FHibernate%E4%B8%AD%E7%9A%84mappedBy%E5%92%8C%E6%B3%A8%E8%A7%A3-JoinColumn%2F</url>
    <content type="text"><![CDATA[mappedBymappedBy用于指定具有双向关系的两个实体中。哪个实体是被关联处理的。 只有OneToOne,OneToMany,ManyToMany上才有mappedBy属性，ManyToOne不存在该属性@OneToMany(mappedBy=“由One的一方指向Many的一方，并且，这个属性应该等于Many的一方中含有One类的属性的对象名，否则会出错”)关系的拥有方(Many的一方)负责关系的维护，在拥有方建立外键。所以用到@JoinColumn12345678910111213141516import javax.persistence.*;import java.util.Set;@Entity@Tablepublic class Users &#123; @Id @Column private Integer id; private String name; //mappedBy由One的一方指向Many的一方，并且，这个属性应该等于Many的一方中含有One类的属性的对象名 @OneToMany(targetEntity = House.class, mappedBy = "user_id") private Set&lt;House&gt; houseSet;&#125; JoinColumn@JoinColumn指定了Users通过外键u_id关联到当前的user_id。用@JoinColumn指向One的一个外键字段(数据库对应外键字段名)。 12345678910111213141516import javax.persistence.*;import java.util.Date;@Entity@Tablepublic class House &#123; @Id @Column private Integer id; private String title; @ManyToOne(targetEntity = Users.class) @JoinColumn(name = "u_id") private Users user_id;&#125;]]></content>
      <categories>
        <category>Hibernate</category>
        <category>注解</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
        <tag>mappedBy</tag>
        <tag>JoinColumn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Open Session In View 模式]]></title>
    <url>%2F2017%2F06%2F06%2FOpen-Session-In-View-%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是 Open Session In View 模式在hibernate中使用load方法时，并未把数据真正获取时就关闭了session，当我们真正想获取数据时会迫使load加载数据，而此时 session已关闭，所以就会出现异常。 比较典型的是在MVC模式中，我们在M层调用持久层获取数据时(持久层用的是load方法加载数据)，当这一调用结束时，session随之关闭，而我们 希望在V层使用这些数据，这时才会迫使load加载数据，我们就希望这时的session是open着得，这就是所谓的Open Session In view 。 我们可以filter来达到此目的 OpenSesstionInViewFilter.java 的主要代码123456789101112131415161718192021222324252627282930313233343536package com.accp.filter;import com.accp.util.HibernateUtil;import org.hibernate.HibernateException;import org.hibernate.Transaction;import javax.servlet.*;import java.io.IOException;public class OpenSesstionInViewFilter implements Filter &#123; public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; Transaction transaction = null; try &#123; System.out.println("请求到达时打开session并启动事务"); transaction = HibernateUtil.currentSesstion().beginTransaction(); System.out.println("执行请求处理链"); filterChain.doFilter(servletRequest, servletResponse); System.out.println("返回响应时，提交事务"); transaction.commit(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (transaction != null) &#123; transaction.rollback(); System.out.println("回滚事务"); &#125; &#125; &#125; public void destroy() &#123; &#125;&#125; web.xml 中 Filter 的配置123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" version="3.0"&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;filter&gt; &lt;filter-name&gt;OpenSesstionInView&lt;/filter-name&gt; &lt;filter-class&gt;com.accp.filter.OpenSesstionInViewFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;OpenSesstionInView&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt;]]></content>
      <categories>
        <category>Hibernate</category>
        <category>Session</category>
        <category>Filter</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
        <tag>Session</tag>
        <tag>Filter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用工具类管理SessionFactory和Session]]></title>
    <url>%2F2017%2F06%2F06%2F%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%AE%A1%E7%90%86SessionFactory%E5%92%8CSession%2F</url>
    <content type="text"><![CDATA[使用工具类管理SessionFactory和Session12345678910111213141516171819202122232425import org.hibernate.HibernateException;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.cfg.Configuration;public class HibernateUtil &#123; private static Configuration configuration; private final static SessionFactory sessionFactory; //初始化Configuration和SessionFactory static &#123; try &#123; //配置文件名，来源resources 根目录 configuration = new Configuration().configure("hibernate.cfg.xml"); sessionFactory = configuration.buildSessionFactory(); &#125; catch (HibernateException e) &#123; throw new ExceptionInInitializerError(e); &#125; &#125; //获取Session对象 public static Session currentSesstion() &#123; return sessionFactory.getCurrentSession(); &#125;&#125;]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
        <tag>Session</tag>
        <tag>SessionFactory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea建立WebServlet遇到的问题]]></title>
    <url>%2F2017%2F06%2F06%2Fidea%E5%BB%BA%E7%AB%8BWebServlet%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[直接用idea建立的web项目，其自动生成的web.xml，这样建立servlet-name等标签会报错（不支持这种做法，更提倡用注解的办法），解决办法是将web-app标签替换成以下的3.0版本1234&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" version="3.0"&gt; 随后创建 Java 类 继承 javax.servlet.http.HttpServlet123456789101112131415161718import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet("/hello")public class selectServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req, resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println("Simon"); &#125;&#125; 利用注解进行配置12//在servlet类的上面写入注解@WebServlet("/hello")@WebServlet("/hello") pom.xml 配置12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;chapter6d4&lt;/name&gt; &lt;groupId&gt;com&lt;/groupId&gt; &lt;artifactId&gt;chapter6d4&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;5.2.12.Final&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.hynnet/oracle-driver-ojdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;com.oracle&lt;/groupId&gt; &lt;artifactId&gt;ojdbc6&lt;/artifactId&gt; &lt;version&gt;12.1.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;]]></content>
      <categories>
        <category>idea</category>
        <category>web.xml</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>servlet</tag>
        <tag>Javaweb</tag>
        <tag>web.xml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate配置文件hibernate.cfg.xml和.hbm.xml的详细解释]]></title>
    <url>%2F2017%2F05%2F31%2FHibernate%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6hibernate-cfg-xml%E5%92%8C-hbm-xml%E7%9A%84%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A%2F</url>
    <content type="text"><![CDATA[什么是HibernateHibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用，最具革命意义的是，Hibernate可以在应用EJB的J2EE架构中取代CMP，完成数据持久化的重任。 Hibernate配置文件hibernate.cfg.xml和.hbm.xml的详细解释Hibernate 中有两个常见的配置文件 hibernate.cfg.xml 和 XXX.hbm.xml 其中 Maven 项目对象模型的 pom.xml 可以去 Maven知识库 得到对应的 dependency 部分 如需手动导入文件，先下载文件。并用 mvn 执行 1mvn install:install-file -Dfile=下载文件所在路径 -DgroupId=dependency配置的groupId部分 -DartifactId=dependency配置的artifactId部分 -Dversion=dependency配置的版本 -Dpackaging=属于什么文件 例如 1mvn install:install-file -Dfile=c:\ojdbc6.jar -DgroupId=com.oracle -DartifactId=ojdbc6 -Dversion=11.2.0.1.0 -Dpackaging=jar hibernate.cfg.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;!--标准的XML文件的起始行，version='1.0'表明XML的版本，encoding='gb2312'表明XML文件的编码方式--&gt; &lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!--表明解析本XML文件的DTD文档位置，DTD是Document Type Definition 的缩写,即文档类型的定义,XML解析器使用DTD文档来检查XML文件的合法性。hibernate.sourceforge.net/hibernate-configuration-3.0dtd可以在Hibernate3.1.3软件包中的src\org\hibernate目录中找到此文件--&gt; &lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt; &lt;!--声明Hibernate配置文件的开始--&gt; &lt;hibernate-configuration&gt; &lt;!--表明以下的配置是针对session-factory配置的，SessionFactory是Hibernate中的一个类，这个类主要负责保存HIbernate的配置信息，以及对Session的操作--&gt; &lt;session-factory&gt; &lt;!--配置数据库的驱动程序，Hibernate在连接数据库时，需要用到数据库的驱动程序--&gt; &lt;property name="hibernate.connection.driver_class"&gt;oracle.jdbc.driver.OracleDriver &lt;/property&gt; &lt;!--设置数据库的连接url:jdbc:mysql://localhost/hibernate,其中localhost表示mysql服务器名称，此处为本机， hibernate是数据库名--&gt; &lt;property name="hibernate.connection.url"&gt;jdbc:mysql://localhost/hibernate&lt;/property&gt; &lt;!--连接数据库是用户名--&gt; &lt;property name="hibernate.connection.username"&gt;root &lt;/property&gt; &lt;!--连接数据库是密码--&gt; &lt;property name="hibernate.connection.password"&gt;123456 &lt;/property&gt; &lt;!--数据库连接池的大小--&gt; &lt;property name="hibernate.connection.pool.size"&gt;20 &lt;/property&gt; &lt;!--是否在后台显示Hibernate用到的SQL语句，开发时设置为true，便于差错，程序运行时可以在Eclipse的控制台显示Hibernate的执行Sql语句。项目部署后可以设置为false，提高运行效率--&gt; &lt;property name="hibernate.show_sql"&gt;true &lt;/property&gt; &lt;!--jdbc.fetch_size是指Hibernate每次从数据库中取出并放到JDBC的Statement中的记录条数。Fetch Size设的越大，读数据库的次数越少，速度越快，Fetch Size越小，读数据库的次数越多，速度越慢--&gt; &lt;property name="jdbc.fetch_size"&gt;50 &lt;/property&gt; &lt;!--jdbc.batch_size是指Hibernate批量插入,删除和更新时每次操作的记录数。Batch Size越大，批量操作的向数据库发送Sql的次数越少，速度就越快，同样耗用内存就越大--&gt; &lt;property name="jdbc.batch_size"&gt;23 &lt;/property&gt; &lt;!--jdbc.use_scrollable_resultset是否允许Hibernate用JDBC的可滚动的结果集。对分页的结果集。对分页时的设置非常有帮助--&gt; &lt;property name="jdbc.use_scrollable_resultset"&gt;false &lt;/property&gt; &lt;!--connection.useUnicode连接数据库时是否使用Unicode编码--&gt; &lt;property name="Connection.useUnicode"&gt;true &lt;/property&gt; &lt;!--connection.characterEncoding连接数据库时数据的传输字符集编码方式，最好设置为gbk，用gb2312有的字符不全--&gt; &lt;property name="connection.characterEncoding"&gt;gbk &lt;/property&gt; &lt;!--hibernate.dialect 只是Hibernate使用的数据库方言,就是要用Hibernate连接那种类型的数据库服务器。--&gt; &lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect &lt;/property&gt; &lt;!--指定映射文件为“hibernate/ch1/UserInfo.hbm.xml”--&gt; &lt;mapping resource="org/mxg/UserInfo.hbm.xml"&gt; &lt;/session-factory&gt; &lt;/hibernate-configuration&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; //连接驱动 &lt;property name="driverClassName" value="$&#123;jdbc.driverClassName&#125;" /&gt; //连接url, &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; //连接用户名 &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; //连接密码 &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;/bean&gt; &lt;bean id="hbSessionFactory" class="org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;property name="configLocation"&gt; //hibernate配置文件位置 &lt;value&gt;WEB-INF/hibernate.cfg.xml &lt;/value&gt; &lt;/property&gt; &lt;property name="configurationClass" value="org.hibernate.cfg.AnnotationConfiguration" /&gt; &lt;property name="hibernateProperties"&gt; &lt;props&gt; //针对oracle数据库的方言,特定的关系数据库生成优化的SQL &lt;prop key="hibernate.dialect"&gt; org.hibernate.dialect.OracleDialect &lt;/prop&gt; //选择HQL解析器的实现 &lt;prop key="hibernate.query.factory_class"&gt; org.hibernate.hql.ast.ASTQueryTranslatorFactory &lt;/prop&gt; //是否在控制台打印sql语句 &lt;prop key="hibernate.show_sql"&gt;true &lt;/prop&gt; //在Hibernate系统参数中hibernate.use_outer_join被打开的情况下,该参数用来允许使用outer join来载入此集合的数据。 &lt;prop key="hibernate.use_outer_join"&gt;true &lt;/prop&gt; //默认打开，启用cglib反射优化。cglib是用来在Hibernate中动态生成PO字节码的，打开优化可以加快字节码构造的速度 &lt;prop key="hibernate.cglib.use_reflection_optimizer"&gt;true &lt;/prop&gt; //输出格式化后的sql,更方便查看 &lt;prop key="hibernate.format_sql"&gt;true &lt;/prop&gt; //“useUnicode”和“characterEncoding”决定了它是否在客户端和服务器端传输过程中进行Encode，以及如何进行Encode &lt;prop key="hibernate.connection.useUnicode"&gt;true &lt;/prop&gt; //允许查询缓存, 个别查询仍然需要被设置为可缓存的. &lt;prop key="hibernate.cache.use_query_cache"&gt;false &lt;/prop&gt; &lt;prop key="hibernate.default_batch_fetch_size"&gt;16 &lt;/prop&gt; //连接池的最大活动个数 &lt;prop key="hibernate.dbcp.maxActive"&gt;100 &lt;/prop&gt; //当连接池中的连接已经被耗尽的时候，DBCP将怎样处理(0 = 失败,1 = 等待,2 = 增长) &lt;prop key="hibernate.dbcp.whenExhaustedAction"&gt;1 &lt;/prop&gt; //最大等待时间 &lt;prop key="hibernate.dbcp.maxWait"&gt;1200 &lt;/prop&gt; //没有人用连接的时候，最大闲置的连接个数 &lt;prop key="hibernate.dbcp.maxIdle"&gt;10 &lt;/prop&gt; ##以下是对prepared statement的处理，同上。 &lt;prop key="hibernate.dbcp.ps.maxActive"&gt;100 &lt;/prop&gt; &lt;prop key="hibernate.dbcp.ps.whenExhaustedAction"&gt;1 &lt;/prop&gt; &lt;prop key="hibernate.dbcp.ps.maxWait"&gt;1200 &lt;/prop&gt; &lt;prop key="hibernate.dbcp.ps.maxIdle"&gt;10 &lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; XXX.hbm.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?xml version="1.0"?&gt; &lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt; &lt;!-- &lt;hibernate-mapping&gt;一般不去配置，采用默认即可。 default-cascade="none"：默认的级联风格，表与表联动。 default-lazy="true"：默认延迟加载 --&gt; &lt;hibernate-mapping&gt; &lt;!-- &lt;class&gt;：使用class元素定义一个持久化类。 name="cn.javass.user.vo.UserModel"：持久化类的java全限定名； table="tbl_user"：对应数据库表名； mutable="true"：默认为true，设置为false时则不可以被应用程序更新或删除； dynamic-insert="false"：默认为false，动态修改那些有改变过的字段，而不用修改所有字段； dynamic-update="false"：默认为false，动态插入非空值字段； select-before-update="false"：默认为false，在修改之前先做一次查询，与用户的值进行对比，有变化都会真正更新； optimistic-lock="version"：默认为version(检查version/timestamp字段)，取值：all(检查全部字段)、dirty(只检查修改过的字段)、 none(不使用乐观锁定)，此参数主要用来处理并发，每条值都有固定且唯一的版本，版本为最新时才能执行操作； --&gt; &lt;class name="cn.javass.user.vo.UserModel" table="tbl_user" dynamic-insert="true" dynamic-update="true" optimistic-lock="version"&gt; &lt;!-- &lt;id&gt;：定义了该属性到数据库表主键字段的映射。 name="userId"：标识属性的名字； column="userId"：表主键字段的名字，如果不填写与name一样； --&gt; &lt;id name="userId"&gt; &lt;!-- &lt;generator&gt;：指定主键由什么生成，推荐使用uuid（随机生成唯一通用的表示符，实体类的ID必须是String）， native（让数据库自动选择用什么生成（根据底层数据库的能力选择identity，sequence或hilo中的一种））， assigned（指用户手工填入，默认）。 --&gt; &lt;generator class="uuid"/&gt; &lt;/id&gt; &lt;!-- &lt;version/&gt;：使用版本控制来处理并发，要开启optimistic-lock="version"和dynamic-update="true"。 name="version"：持久化类的属性名，column="version"：指定持有版本号的字段名； --&gt; &lt;version name="version" column="version"/&gt; &lt;!-- &lt;property&gt;：为类定义一个持久化的javaBean风格的属性。 name="name"：标识属性的名字，以小写字母开头； column="name"：表主键字段的名字，如果不填写与name一样； update="true"/insert="true"：默认为true，表示可以被更新或插入； --&gt; &lt;property name="name" column="name" /&gt; &lt;property name="sex" column="sex"/&gt; &lt;property name="age" column="age"/&gt; &lt;!-- 组件映射：把多个属性打包在一起当一个属性使用，用来把类的粒度变小。 &lt;component name="属性，这里指对象"&gt; &lt;property name="name1"&gt;&lt;/property&gt; &lt;property name="name2"&gt;&lt;/property&gt; &lt;/component&gt; --&gt; &lt;!-- &lt;join&gt;:一个对象映射多个表，该元素必须放在所有&lt;property&gt;之后。 &lt;join table="tbl_test：子表名"&gt; &lt;key column="uuid：子表主键"&gt;&lt;/key&gt; &lt;property name="name1：对象属性" column="name：子表字段"&gt;&lt;/property&gt; &lt;/join&gt; --&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt;]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next主题个性化教程]]></title>
    <url>%2F2017%2F04%2F05%2FTheme-of-personalized%2F</url>
    <content type="text"><![CDATA[在右上角或者左上角实现fork me on github点击 GitHub Corners 或者 点击 GitHub Ribbons 挑选自己喜欢的样式，并复制代码。 然后粘贴刚才复制的代码到 themes/Hexo主题文件夹/layout/导航栏定义文件 的文件中(代码放置位置自行调节)，例如 Next主题 位于 themes/next/layout/_layout.swig 并把href改为你的GitHub地址 添加 README.md 文件每个项目下一般都有一个 README.md 文件，但是使用 Hexo 部署到仓库后，项目下是没有 README.md 文件的。 在 Hexo 目录下的 source 根目录下添加一个 README.md 文件，修改站点配置文件 _config.yml 将 skip_render 参数的值设置为 1skip_render: README.md 侧边栏社交小图标设置打开主题配置文件 _config.yml 搜索 social_icons: 在图标库找自己喜欢的小图标，并将名字复制到对应的键值对 在网站底部加上访问量打开 \themes\next\layout\_partials\footer.swig 文件,在copyright前加上： 1&lt;script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; 然后在合适的位置添加显示统计的代码 12345&lt;div class="powered-by"&gt;&lt;i class="fa fa-user-md"&gt;&lt;/i&gt;&lt;span id="busuanzi_container_site_uv"&gt;本站访客数:&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt; 在这里有两中不同计算方式的统计代码pv的方式，单个用户连续点击n篇文章，记录n次访问量123&lt;span id="busuanzi_container_site_pv"&gt; 本站总访问量&lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt;次&lt;/span&gt; uv的方式，单个用户连续点击n篇文章，只记录1次访客数123&lt;span id="busuanzi_container_site_uv"&gt; 本站总访问量&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;次&lt;/span&gt; 添加之后再执行 hexo d -g 然后再刷新页面就能看到效果 网站底部字数统计切换到根目录下，然后运行如下代码 1$ npm install hexo-wordcount --save 然后在 /themes/next/layout/_partials/footer.swig 文件尾部加上： 1234&lt;div class="theme-info"&gt; &lt;div class="powered-by"&gt;&lt;/div&gt; &lt;span class="post-count"&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 实现统计功能在根目录下安装 hexo-wordcount 运行： 1$ npm install hexo-wordcount --save 然后在主题的配置文件中，配置如下： 123456# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true 每次 hexo new “My New Post” 生成默认的md文件格式在 /scaffolds/post.md 文件中修改默认格式 隐藏网页底部powered By Hexo / 强力驱动打开 themes/next/layout/_partials/footer.swig 使用 &lt;!-- --&gt; 隐藏之间的代码即可，或者直接删除 文章加密访问打开 themes/next/layout/_partials/head.swig 文件，在以下位置插入这样一段代码： 12345678910&lt;script&gt; (function()&#123; if('&#123;&#123; page.password &#125;&#125;')&#123; if (prompt('请输入访问密码') !== '&#123;&#123; page.password &#125;&#125;')&#123; alert('访问失败'); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 然后在文章上定义键值对密码 12345678910---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags: - 标签category: - 分类comments: truepassword: password--- 自定义鼠标样式打开 themes/next/source/css/_custom/custom.styl 在里面写下如下代码： 1234567// 鼠标样式 * &#123; cursor: url("http://om8u46rmb.bkt.clouddn.com/sword2.ico"),auto!important &#125; :active &#123; cursor: url("http://om8u46rmb.bkt.clouddn.com/sword1.ico"),auto!important &#125; 其中 url 里面必须是 ico 图片，ico 图片可以上传到网上 点击爆炸效果首先在 themes/next/source/js/src 里面建一个叫 fireworks.js 的文件，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137"use strict";function updateCoords(e) &#123; pointerX = (e.clientX || e.touches[0].clientX) - canvasEl.getBoundingClientRect().left, pointerY = e.clientY || e.touches[0].clientY - canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e) &#123; var t = anime.random(0, 360) * Math.PI / 180, a = anime.random(50, 180), n = [-1, 1][anime.random(0, 1)] * a; return &#123;x: e.x + n * Math.cos(t), y: e.y + n * Math.sin(t)&#125;&#125;function createParticule(e, t) &#123; var a = &#123;&#125;; return a.x = e, a.y = t, a.color = colors[anime.random(0, colors.length - 1)], a.radius = anime.random(16, 32), a.endPos = setParticuleDirection(a), a.draw = function () &#123; ctx.beginPath(), ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0), ctx.fillStyle = a.color, ctx.fill() &#125;, a&#125;function createCircle(e, t) &#123; var a = &#123;&#125;; return a.x = e, a.y = t, a.color = "#F00", a.radius = 0.1, a.alpha = 0.5, a.lineWidth = 6, a.draw = function () &#123; ctx.globalAlpha = a.alpha, ctx.beginPath(), ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0), ctx.lineWidth = a.lineWidth, ctx.strokeStyle = a.color, ctx.stroke(), ctx.globalAlpha = 1 &#125;, a&#125;function renderParticule(e) &#123; for (var t = 0; t &lt; e.animatables.length; t++) &#123; e.animatables[t].target.draw() &#125;&#125;function animateParticules(e, t) &#123; for (var a = createCircle(e, t), n = [], i = 0; i &lt; numberOfParticules; i++) &#123; n.push(createParticule(e, t)) &#125; anime.timeline().add(&#123; targets: n, x: function (e) &#123; return e.endPos.x &#125;, y: function (e) &#123; return e.endPos.y &#125;, radius: 0.1, duration: anime.random(1200, 1800), easing: "easeOutExpo", update: renderParticule &#125;).add(&#123; targets: a, radius: anime.random(80, 160), lineWidth: 0, alpha: &#123;value: 0, easing: "linear", duration: anime.random(600, 800)&#125;, duration: anime.random(1200, 1800), easing: "easeOutExpo", update: renderParticule, offset: 0 &#125;)&#125;function debounce(e, t) &#123; var a; return function () &#123; var n = this, i = arguments; clearTimeout(a), a = setTimeout(function () &#123; e.apply(n, i) &#125;, t) &#125;&#125;var canvasEl = document.querySelector(".fireworks");if (canvasEl) &#123; var ctx = canvasEl.getContext("2d"), numberOfParticules = 30, pointerX = 0, pointerY = 0, tap = "mousedown", colors = ["#FF1461", "#18FF92", "#5A87FF", "#FBF38C"], setCanvasSize = debounce(function () &#123; canvasEl.width = 2 * window.innerWidth, canvasEl.height = 2 * window.innerHeight, canvasEl.style.width = window.innerWidth + "px", canvasEl.style.height = window.innerHeight + "px", canvasEl.getContext("2d").scale(2, 2) &#125;, 500), render = anime(&#123; duration: 1 / 0, update: function () &#123; ctx.clearRect(0, 0, canvasEl.width, canvasEl.height) &#125; &#125;); document.addEventListener(tap, function (e) &#123; "sidebar" !== e.target.id &amp;&amp; "toggle-sidebar" !== e.target.id &amp;&amp; "A" !== e.target.nodeName &amp;&amp; "IMG" !== e.target.nodeName &amp;&amp; (render.play(), updateCoords(e), animateParticules(pointerX, pointerY)) &#125;, !1), setCanvasSize(), window.addEventListener("resize", setCanvasSize, !1)&#125;"use strict";function updateCoords(e) &#123; pointerX = (e.clientX || e.touches[0].clientX) - canvasEl.getBoundingClientRect().left, pointerY = e.clientY || e.touches[0].clientY - canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e) &#123; var t = anime.random(0, 360) * Math.PI / 180, a = anime.random(50, 180), n = [-1, 1][anime.random(0, 1)] * a; return &#123;x: e.x + n * Math.cos(t), y: e.y + n * Math.sin(t)&#125;&#125;function createParticule(e, t) &#123; var a = &#123;&#125;; return a.x = e, a.y = t, a.color = colors[anime.random(0, colors.length - 1)], a.radius = anime.random(16, 32), a.endPos = setParticuleDirection(a), a.draw = function () &#123; ctx.beginPath(), ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0), ctx.fillStyle = a.color, ctx.fill() &#125;, a&#125;function createCircle(e, t) &#123; var a = &#123;&#125;; return a.x = e, a.y = t, a.color = "#F00", a.radius = 0.1, a.alpha = 0.5, a.lineWidth = 6, a.draw = function () &#123; ctx.globalAlpha = a.alpha, ctx.beginPath(), ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0), ctx.lineWidth = a.lineWidth, ctx.strokeStyle = a.color, ctx.stroke(), ctx.globalAlpha = 1 &#125;, a&#125;function renderParticule(e) &#123; for (var t = 0; t &lt; e.animatables.length; t++) &#123; e.animatables[t].target.draw() &#125;&#125;function animateParticules(e, t) &#123; for (var a = createCircle(e, t), n = [], i = 0; i &lt; numberOfParticules; i++) &#123; n.push(createParticule(e, t)) &#125; anime.timeline().add(&#123; targets: n, x: function (e) &#123; return e.endPos.x &#125;, y: function (e) &#123; return e.endPos.y &#125;, radius: 0.1, duration: anime.random(1200, 1800), easing: "easeOutExpo", update: renderParticule &#125;).add(&#123; targets: a, radius: anime.random(80, 160), lineWidth: 0, alpha: &#123;value: 0, easing: "linear", duration: anime.random(600, 800)&#125;, duration: anime.random(1200, 1800), easing: "easeOutExpo", update: renderParticule, offset: 0 &#125;)&#125;function debounce(e, t) &#123; var a; return function () &#123; var n = this, i = arguments; clearTimeout(a), a = setTimeout(function () &#123; e.apply(n, i) &#125;, t) &#125;&#125;var canvasEl = document.querySelector(".fireworks");if (canvasEl) &#123; var ctx = canvasEl.getContext("2d"), numberOfParticules = 30, pointerX = 0, pointerY = 0, tap = "mousedown", colors = ["#FF1461", "#18FF92", "#5A87FF", "#FBF38C"], setCanvasSize = debounce(function () &#123; canvasEl.width = 2 * window.innerWidth, canvasEl.height = 2 * window.innerHeight, canvasEl.style.width = window.innerWidth + "px", canvasEl.style.height = window.innerHeight + "px", canvasEl.getContext("2d").scale(2, 2) &#125;, 500), render = anime(&#123; duration: 1 / 0, update: function () &#123; ctx.clearRect(0, 0, canvasEl.width, canvasEl.height) &#125; &#125;); document.addEventListener(tap, function (e) &#123; "sidebar" !== e.target.id &amp;&amp; "toggle-sidebar" !== e.target.id &amp;&amp; "A" !== e.target.nodeName &amp;&amp; "IMG" !== e.target.nodeName &amp;&amp; (render.play(), updateCoords(e), animateParticules(pointerX, pointerY)) &#125;, !1), setCanvasSize(), window.addEventListener("resize", setCanvasSize, !1)&#125;; 打开 themes/next/layout/_layout.swig 在 &lt;/body&gt; 上面写下如下代码： 12345&#123;% if theme.fireworks %&#125; &lt;canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" &gt;&lt;/canvas&gt; &lt;script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/js/src/fireworks.js"&gt;&lt;/script&gt;&#123;% endif %&#125; 打开主题配置文件，在里面最后写下： 12# Fireworksfireworks: true]]></content>
      <categories>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>搭建博客</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建个人博客]]></title>
    <url>%2F2017%2F03%2F17%2FHexo-build-blog%2F</url>
    <content type="text"><![CDATA[准备工作了解HexoHexo是高效的静态站点生成框架，她基于Node.js。 通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的标签插件来快速的插入特定形式的内容，而且相对于其他框架，Hexo在速度上也有很大优势。 搭建Node.js环境我们了解到Hexo基于Node.js的，那么我们搭建博客网站首先需要安装Node.js环境。 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，可以在非浏览器环境下，解释运行 JS 代码。 点击下载 Node.js 测试安装：命令行使用 node -v 和 npm -v 查看显示版本号即成功。 安装Hexo博客框架工具Hexo是一个建站工具，可以帮助我们快速生成基本的博客文件，安装它需要在控制台下使用如下命令： 1npm install hexo-cli -g 安装Git版本工具Git是目前世界上最流行的分布式版本控制系统，是的，没有之一。使用Git可以帮助我们把本地的网页和文章等内容提交到Gihub上，实现同步。 点击下载 Git Windows系统需下载，Mac系统因为自带Git无需操作。测试安装：命令行使用 git --version 查看显示版本号即成功。 注册Github账号Github是一个面向开源及私有软件项目的托管平台，因为只支持 git 作为唯一的版本库格式进行托管，故名Github。这里用到Github，是因为我们需要通过Github得到自己的博客网站域名，而且需要使用Github同步我们个人博客的相关文件。 注册地址： Github 官网注册流程： 百度一下,你就知道 开始搭建博客搭建我们的个人博客需要一个唯一的域名，当然我们可以申请购买一个域名来使用，但是在不是太必要的情况下，我们也可以通过Github Pages获得一个免费使用的域名，这需要我们在Github上新建一个仓库，如下： 勾选 Initialize this repository with a README 避免后面不必要的麻烦 其中的 %username% 替换成Github用户名 这个过程和建立普通的仓库没什么区别，关键在于新仓库的名字，一定要是 %username% +“github.io”的形式。这也是之前强调的要起一个好的用户名的原因。这样之后我们最后的博客网站的链接就会是：https://%username%.github.io的形式。注意：固定新仓库的名字格式并非必须，只是这样操作生成的博客域名比较短小简洁，另起他名生成博客域名会很冗长。 点击Create Repository之后，随后选择Setting进入设置，找到Github Pages如下： 这里我们需要点击Choose a theme任意选择一个选择主题，然后界面会跳转到仓库，我们看到有两个文件如下： 此时若再查看Setting，我们会看到开启GitHub Pages之后得到的域名如下： 现在，我们就可以使用 https://%username%.github.io 访问自己的博客网站了，打开链接我们会看到默认主题的个人博客样式如下: 创建本地博客站点上述的步骤相当于我们使用Github page，创建了一个默认的博客页，并且得到了一个可外部访问的域名。但是这个博客页很Low。我们的目的是创建自己个性化的博客网站，所以我们使用Hexo在本地先创建一个本地博客站点，优化后再把它部署到Github上。接下来我们使用控制台命令在本地一个合适的位置创建博客站点文件夹如下： 安装Hexo，在自己认为合适的地方创个文件夹，我是在E盘建了一个blog文件夹。然后通过命令行进入到该文件夹里面 输入 npm install hexo -g 开始安装Hexo 输入 hexo -v 检查Hexo是否安装成功 输入 hexo init 初始化该文件夹 看到后面的 Start blogging with Hexo！ 表示成功 输入 npm install 安装所需要的组件 输入 hexo g g是generetor的缩写，生成博客 输入 hexo s s是server的缩写，启动服务，访问该网址，正式体验Hexo 问题：假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，接着输入 hexo server -p 端口号 来改变端口号 同步Github,允许公共访问在本地我们已经搭建了博客，但是还只能自己本地访问。若要别人也能看到，那就需要我们将其同步部署到GitHub上了。还记得我们之前准备的Github仓库吗，这里就要用到了。首先找到我们的博客仓库，并拷贝仓库地址： 修改本地博客根目录下的_config.yml文件，修改deploy下的配置如下： 修改repository值为上面拷贝的仓库地址 1234deploy: type: git repository: git@github.com:%username%/%username%.github.io.git branch: master Git安装后，右键有 Git Base Here 在本地博客文件夹打开 将Hexo与Github page联系起来，设置Git的username和email 12git config --global user.name &quot;Github用户名&quot;git config --global user.email &quot;Github绑定的邮箱&quot; 输入 cd ~/.ssh 检查是否由.ssh的文件夹 输入 ls 列出该文件下的内容 输入 ssh-keygen -t rsa -C “Github绑定的邮箱” 连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator\.ssh） 输入 eval &quot;$(ssh-agent -s)&quot; 添加密钥到ssh-agent 输入 ssh-add ~/.ssh/id_rsa 添加生成的SSH key到ssh-agent 登录Github，点击头像下的Settings进入SSH and GPG keys选项，添加SSH keys 新建一个New SSH key，将id_rsa.pub文件里的内容复制上去 输入 ssh -T git@github.com 测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了 新建一篇博客，用控制台定位到本地博客文件夹执行命令 hexo new &quot;My New Post&quot; 这时候在文件夹_posts目录下将会看到已经创建的文件 在生成以及部署文章之前，需要安装一个扩展：npm install hexo-deployer-git --save 使用编辑器编好文章，那么就可以使用命令： hexo d -g 生成以及部署了 部署成功后访问你的地址将看到生成的文章]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>搭建博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合总结]]></title>
    <url>%2F2016%2F11%2F12%2FJava%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Java集合类型123456//Java导包import java.util.List;import java.util.ArrayList;import java.util.Map;import java.util.HashMap;import java.util.Hashtable; 泛型集合前面的都是接口1234567891011 /** * 泛型集合 */List&lt;String&gt; list = new ArrayList&lt;String&gt;();/** * K键泛型集合 */Map&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;();//Map添加数据map.put(Integer, String); //put塞入的意思 集合前面的都是类123456789101112 /** * 集合 */ArrayList array = new ArrayList();/** * K键集合 */Hashtable hashtable = new Hashtable();/** * Set集合 //唯一 //里面的值不能有重复的;重复添加不报错;会替换最后添加 */Set set = new HashSet(); 集合操作12//清空集合数据list.clear(); ArrayList集合的应用1234567891011121314151617181920212223242526//声明集合List list = new ArrayList();//新增数据list.add(Object类型值).list.add(int 索引号，值)//得到集合个数list.size(); //长度//得到集合里面的数据Object obj = (集合存储数据类型)list.get(int i); //get得到集合下标位置int 类型 i 的数据//删除方式lis.remove(0); //删除索引第一个的数据lis.remove(Object类型值); //按照指定的对象名删除//判断集合中的对象是否存在if(list.contains(集合存储数据类型对象))&#123; //返回Boolean类型 存在为true&#125; 遍历方式(调用集合数据里的对象方法)123456789101112//增强for循环for(Object obj : list)&#123; ((集合存储数据类型)obj).该对象拥有的方法;&#125;//for循环for(int i = 0; i &lt; list.Size(); i++)&#123; Object obj = (集合存储数据类型)list.get(i); //get得到集合下标位置的数据 集合存储数据类型 字段名 = (集合存储数据类型)obj; //拆箱 字段名.该对象拥有的方法;&#125; LinkedList集合的应用1234567891011121314151617//声明集合LinkedList list = new LinkedList();//新增数据(在ArrayList基础上新增方法)list.addFirst(Object类型值); //新增到第一个位置list.addLast(Object类型值); //新增到最后一个位置//得到集合里面的数据(在ArrayList基础上新增方法)Object obj = (集合存储数据类型)list.getFirst(); //getFirst得到集合第一个位置的数据Object obj = (集合存储数据类型)list.getLast(); //getLast得到集合最后一个位置的数据//删除方式(在ArrayList基础上新增方法)list.removeFirst(); //删除第一个对象list.removeLast(); //删除最后一个对象 K键123456789101112131415161718192021222324//判断带K键的集合中的K键是否存在if(list.containsKey(集合存储K键类型值))&#123; //返回Boolean类型 存在为true&#125;//判断带K键的集合中的Value值是否存在if(list.containsValue(集合存储Value类型值))&#123; //返回Boolean类型 存在为true&#125;//得到集合里面的数据集合存value储数据类型 value = (集合存储value数据类型)list.get(key); //get得到集合指定的K键名的value 数据//删除方式lis.remove(集合存储K键类型值); //按照指定的K键名删除对象//分别显示键集 / 值集 / 键值对集合list.keySet(); //键集list.values(); //值集list; //键值对集合 迭代器1234567Set keys = map.keySet(); //迭代器方式Iterator it = keys.iterator(); //获得Iterator对象while(it.hasNext())&#123; String key = (String)it.next(); //获得键名 集合存value储数据类型 value = (集合存储value数据类型)list.get(key); //get得到集合指定的K键名的value 数据 value.该对象拥有的方法;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>集合</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何解决JavaScript中0.1+0.2不等于0.3]]></title>
    <url>%2F2016%2F10%2F22%2F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3JavaScript%E4%B8%AD0-1-0-2%E4%B8%8D%E7%AD%89%E4%BA%8E0-3%2F</url>
    <content type="text"><![CDATA[如何解决JavaScript中0.1+0.2不等于0.31console.log(0.1+0.2===0.3); //true or false? 在正常的数学逻辑思维中，0.1+0.2=0.3这个逻辑是正确的，但是在JavaScript中0.1+0.2!==0.3，这是为什么呢？这个问题也会偶尔被用来当做面试题来考查面试者对JavaScript的数值的理解程度 在JavaScript中的二进制的浮点数0.1和0.2并不是十分精确，在他们相加的结果并非正好等于0.3，而是一个比较接近的数字 0.30000000000000004 ，所以条件判断结果为 false 那么应该怎样来解决0.1+0.2等于0.3呢? 最好的方法是设置一个误差范围值，通常称为”机器精度“，而对于 JavaScript 来说，这个值通常是2^-52,而在 ES6 中，已经为我们提供了这样一个属性：Number.EPSILON，而这个值正等于2^-52。这个值非常非常小，在底层计算机已经帮我们运算好，并且无限接近0，但不等于0,。这个时候我们只要判断(0.1+0.2)-0.3小于Number.EPSILON，在这个误差的范围内就可以判定0.1+0.2===0.3为true 12345function numbersEqual(a,b)&#123; return Math.abs(a-b)&lt;Number.EPSILON; &#125; var a=0.1+0.2， b=0.3; console.log(numbersEqual(a,b)); //true]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 语法 API]]></title>
    <url>%2F2016%2F09%2F18%2FMarkdown-Syntax-API%2F</url>
    <content type="text"><![CDATA[Markdown：语法概观 哲学 Markdown旨在尽可能易于阅读和易于编写。 但是，可读性强调一切。Markdown格式的文档应该以纯文本的形式发布，而不会看起来像标签或格式化指令。尽管Markdown的语法受到了几种现有的文本到HTML过滤器的影响，包括 Setext， atx， Textile， reStructuredText，Grutatext， 和 EtText ，Markdown语法的最大灵感来源是纯文本电子邮件的格式。 为此，Markdown的语法完全由标点字符组成，标点字符经过仔细选择以便看起来像他们的意思。 例如，一个词的星号实际上看起来像 *强调*。 Markdown列表看起来就像列表。 即使blockquotes看起来像引用的文本段落，假设你曾经使用过电子邮件。 内联HTML Markdown的语法仅用于一个目的：用作网络 书写 的格式。 Markdown不是HTML的替代品，甚至不接近它。 它的语法非常小，仅对应于HTML标签的一小部分。 这个想法 并不是 创建一个使插入HTML标签更容易的语法。 在我看来，HTML标签已经很容易插入。 Markdown的想法是让阅读，写作和阅读变得容易编辑散文。 HTML是一种 发布 格式; Markdown是一种 书写 格式。 因此，Markdown的格式化语法只能解决以纯文本形式传达的问题。 对于Markdown语法未涉及的任何标记，您只需使用HTML本身。 没有必要在前言或分隔它以表明您正在从Markdown切换到HTML; 你只需使用标签。 唯一的限制是块级HTML元素 - 例如 &lt;div&gt;， &lt;table&gt;， &lt;pre&gt;， &lt;p&gt; 等等。必须通过空行将其与周围内容分开，并且块的开始和结束标记不应该用制表符或空格缩进。 Markdown足够智能，不会在HTML块级标签周围添加额外的（不需要的） &lt;p&gt; 标签。 例如，要将一个HTML表添加到Markdown文章中： 这是一个正常的段落。 12345&lt;table&gt; &lt;tr&gt; &lt;td&gt;Foo&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 这是另一个常规段落。 请注意，Markdown格式化语法不在块级HTML标记中处理。 例如，您不能在HTML块中使用Markdown风格 *重点*。 跨度级HTML标记 - 例如 &lt;span&gt;， &lt;cite&gt; 或 &lt;del&gt; - 可用于Markdown段落，列表项目或标题中的任何位置。 如果你愿意，你甚至可以使用HTML标签而不是Markdown格式; 例如 如果您希望使用HTML &lt;a&gt; 或 &lt;img&gt; 标记而不是Markdown的链接或图像语法，请继续前进。 与块级HTML标签不同，Markdown语法 在 跨度级别标签内处理。 自动转义特殊字符 在HTML中，有两个字符需要特殊处理： &lt; 和 &amp;。 左尖括号用于启动标签; ＆符号用于表示HTML实体。 如果你想用它们作为文字字符，你必须将它们作为实体转义，例如 &amp;lt; 和 &amp;amp;。 特别是对于网络编写者来说，＆符号是很困难的。 如果你想写’AT&amp;T’，你需要写’AT&amp;amp;T‘。 您甚至需要在网址中跳过＆符号。 因此，如果你想链接到： http://images.google.com/images?num=30&amp;q=larry+bird 您需要将URL编码为： http://images.google.com/images?num=30&amp;amp;q=larry+bird 在你的锚标记 href 属性中。 不用说，这很容易被遗忘，并且可能是在其他标记良好的网站中最常见的HTML验证错误来源。 Markdown允许您自然使用这些角色，并为您处理所有必要的转义。 如果使用＆符号作为HTML实体的一部分，则它保持不变; 否则它将被翻译成 &amp;amp;。 所以，如果你想在你的文章中包含一个版权符号，你可以写： &amp;copy; Markdown将不再支持它。 但是如果你写： AT&amp;T Markdown会将其转化为： AT&amp;amp;T 同样，由于Markdown支持 嵌入式HTML，因此如果您使用尖括号作为HTML标签的分隔符，Markdown会像这样对待它们。 但是如果你写： 4 &lt; 5 Markdown会将其转化为： 4 &amp;lt; 5 但是，在Markdown代码跨度和块内部，尖括号和＆符号 总是 自动编码。 这使得使用Markdown很容易编写HTML代码。 （与原始HTML相反，这是一种用于编写HTML语法的可怕格式，因为您的示例代码中的每个 &lt; 和 &amp; 都需要被转义。） 块元素 段落和换行符 段落只是一个或多个连续的文本行，由一个或多个空行分隔。 （空白行是任何看起来像空行的行 - 只包含空格或制表符的行被认为是空白。）普通段落不应该用空格或制表符缩进。 “一条或多条连续文本”规则的含义是Markdown支持“硬包装”文本段落。 这与大多数其他文本到HTML格式化程序（包括Movable Type的“Convert Line Breaks”选项）有很大不同，它将段落中的每个换行符转换为一个 &lt;br /&gt; 标记。 当你 想要 使用Markdown插入一个 &lt;br /&gt; 中断标签时，可以用两个或多个空格结束一行，然后输入返回。 是的，这需要花费更多的努力来创建一个 &lt;br /&gt; ，但是一个简单的“每行换行符都是 &lt;br /&gt; ”规则对于Markdown来说不起作用。 Markdown的电子邮件风格的 块引用 和多段 列表项 最适合 - 并且看起来更好 - 当您用严格的休息格式化它们时。 头 Markdown支持两种标题， Setext 和 atx。 Setext风格的标题是使用等号（用于第一级标题）和破折号（用于第二级标题）的“下划线”。 例如： 这是H1 ============= 这是H2 ------------- 任何数字的下划线 = 或 - 将起作用。 Atx风格的标题在行首使用1-6个哈希字符，对应于标题级别1-6。 例如： # 这是H1 ## 这是H2 ###### 这是一个H6 或者，你可以“关闭”atx风格的头文件。 这纯粹是美容 - 如果你认为它看起来更好，你可以使用它。 结束哈希值甚至不需要匹配用于打开头的哈希数。 （开放散列的数量 确定标题级别。）： # 这是H1 # ## 这是H2 ## ### 这是一个H3 ###### 引用文字 Markdown使用电子邮件风格的 &gt; 字符进行区块引用。如果您熟悉在电子邮件中引用文本段落，那么您知道如何在Markdown中创建块引用。它看起来最好，如果你硬包装的文本，并把 &gt; 每一行前： &gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, &gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. &gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. &gt; &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse &gt; id sem consectetuer libero luctus adipiscing. Markdown可以让你懒惰，只把 &gt; 放在硬包装段落的第一行之前： &gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 块引号可以通过添加额外的 &gt;来嵌套（即块引用）： &gt; This is the first level of quoting. &gt; &gt; &gt; This is nested blockquote. &gt; &gt; Back to the first level. Blockquotes可以包含其他Markdown元素，包括标题，列表和代码块： &gt; ## This is a header. &gt; &gt; 1. This is the first list item. &gt; 2. This is the second list item. &gt; &gt; Here&apos;s some example code: &gt; &gt; return shell_exec(&quot;echo $input | $markdown_script&quot;); 任何体面的文本编辑器都应该使电子邮件式引用变得容易。 例如，使用BBEdit，您可以进行选择并从文本菜单中选择“提高报价级别”。 清单 Markdown支持有序（编号）和无序（项目符号）列表。 无序列表使用星号，加号和连字符 - 可互换– 作为列表标记： * Red * Green * Blue 相当于： + Red + Green + Blue 和： - Red - Green - Blue 有序列表使用数字后跟句点： 1. Bird 2. McHale 3. Parish 请注意，用于标记列表的实际数字对Markdown产生的HTML输出没有影响。 从上面的列表产生的HTML Markdown是： 12345&lt;ol&gt;&lt;li&gt;Bird&lt;/li&gt;&lt;li&gt;McHale&lt;/li&gt;&lt;li&gt;Parish&lt;/li&gt;&lt;/ol&gt; 如果你改为在Markdown中写下这样的列表： 1. Bird 1. McHale 1. Parish 甚至： 3. Bird 1. McHale 8. Parish 你会得到完全相同的HTML输出。 关键是，如果你愿意，你可以在你订购的Markdown列表中使用序号，以便你的源代码中的数字与发布的HTML中的数字相匹配。 但是如果你想懒惰，你不需要。 但是，如果确实使用懒惰列表编号，则仍应以数字1开始列表。在将来的某个时间，Markdown可能支持以任意数字开始的有序列表。 列表标记通常从左边界开始，但可以缩进最多三个空格。 列表标记后面必须跟一个或多个空格或制表符。 为了使列表看起来不错，您可以使用悬挂缩进来包装项目： * Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. * Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 但是如果你想懒惰，你不必： * Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. * Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 如果列表项以空行分隔，Markdown会将这些项目包装在HTML输出中的 &lt;p&gt; 标签中。 例如，这个输入： * Bird * Magic 将变成： 1234&lt;ul&gt;&lt;li&gt;Bird&lt;/li&gt;&lt;li&gt;Magic&lt;/li&gt;&lt;/ul&gt; 但是这个： * Bird * Magic 将变成： 1234&lt;ul&gt;&lt;li&gt;&lt;p&gt;Bird&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Magic&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt; 列表项目可能由多个段落组成。 列表项中的每个后续段落都必须缩进4个空格或一个制表符： 1. This is a list item with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. 2. Suspendisse id sem consectetuer libero luctus adipiscing. 它看起来不错，如果你缩进后续段落的每一行，但在这里再一次，Markdown会让你变得懒惰： * This is a list item with two paragraphs. This is the second paragraph in the list item. You&apos;re only required to indent the first line. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. * Another item in the same list. 要在列表项中放置一个块引用，需要缩进块引用的&gt;分隔符： * A list item with a blockquote: &gt; This is a blockquote &gt; inside a list item. 要将代码块放在列表项中，代码块需要缩进 两次 – 8个空格或两个制表符： * A list item with a code block: &lt;code goes here&gt; 值得注意的是，有可能通过写这样的东西来偶然触发一个有序列表： 1986. What a great season. 换句话说，在一行的开始处的 数字周期空间 序列。 为了避免这种情况，您可以使用反斜杠来避开这段时间： 1986\. What a great season. 代码块 预格式化的代码块用于编写有关编程或标记源代码。 而不是形成正常的段落，字面上解释代码块的行。 Markdown在 &lt;pre&gt; 和 &lt;code&gt; 标签中包装了一个代码块。 要在Markdown中生成代码块，只需将块的每一行缩进至少4个空格或1个标签。 例如，给出这个输入： This is a normal paragraph: This is a code block. Markdown将产生： 1234&lt;p&gt;This is a normal paragraph:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;This is a code block.&lt;/code&gt;&lt;/pre&gt; 从代码块的每一行删除一级缩进 - 4个空格或1个制表符。 例如，这个： Here is an example of AppleScript: tell application &quot;Foo&quot; beep end tell 将变成： 123456&lt;p&gt;Here is an example of AppleScript:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;tell application "Foo" beepend tell&lt;/code&gt;&lt;/pre&gt; 一个代码块会一直持续到它没有缩进的一行（或文章结尾）。 在代码块中，＆符号（&amp;）和尖括号（&lt;和&gt;）会自动转换为HTML实体。 这使得使用Markdown包含示例HTML源代码变得非常简单 - 只需粘贴并缩进即可，Markdown将处理编码＆符号和尖括号的麻烦。 例如，这个： 123&lt;div class="footer"&gt; &amp;copy; 2004 Foo Corporation&lt;/div&gt; 将变成： 1234&lt;pre&gt;&lt;code&gt;&amp;lt;div class="footer"&amp;gt; &amp;amp;copy; 2004 Foo Corporation&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt; 定期Markdown语法不在代码块内处理。 例如，星号只是代码块内的字面星号。 这意味着使用Markdown编写Markdown自己的语法也很容易。 横向规则 您可以通过在一行上单独放置三个或更多连字符，星号或下划线来生成水平规则标签（&lt;hr /&gt;）。 如果你愿意，你可以在连字符或星号之间使用空格。 以下每一行都将生成一条水平线： * * * *** ***** - - - --------------------------------------- 跨度元素 链接 Markdown支持两种链接： 内联 和 引用。 在这两种样式中，链接文本都由[方括号]分隔。 要创建内联链接，请在链接文本的方括号之后立即使用一组常规括号。 在圆括号内，将链接指向的URL以及链接的 可选 标题放在引号中。 例如： This is [an example](http://example.com/ &quot;Title&quot;) inline link. [This link](http://example.net/) has no title attribute. 会产生： 12345&lt;p&gt;This is &lt;a href="http://example.com/" title="Title"&gt;an example&lt;/a&gt; inline link.&lt;/p&gt;&lt;p&gt;&lt;a href="http://example.net/"&gt;This link&lt;/a&gt; has notitle attribute.&lt;/p&gt; 如果您指的是同一台服务器上的本地资源，则可以使用相对路径： See my [About](/about/) page for details. 引用样式链接使用第二组方括号，在其中放置您选择的标签以标识链接： This is [an example][id] reference-style link. 您可以选择使用空格来分隔括号组： This is [an example] [id] reference-style link. 然后，在文档的任何地方，您都可以像这样定义您的链接标签，并单独定义一行： [id]: http://example.com/ &quot;Optional Title Here&quot; 那是： Square brackets containing the link identifier (optionallyindented from the left margin using up to three spaces); followed by a colon; followed by one or more spaces (or tabs); followed by the URL for the link; optionally followed by a title attribute for the link, enclosedin double or single quotes, or enclosed in parentheses. 以下三个链接定义是等价的： [foo]: http://example.com/ &quot;Optional Title Here&quot; [foo]: http://example.com/ &apos;Optional Title Here&apos; [foo]: http://example.com/ (Optional Title Here) 注意： Markdown.pl 1.0.1中有一个已知的错误，它可以防止使用单引号来分隔链接标题。 链接URL可以（可选）用尖括号包围： [id]: &lt;http://example.com/&gt; &quot;Optional Title Here&quot; 您可以将title属性放在下一行，并使用额外的空格或制表符来填充，这对于更长的URL来说往往更好看： [id]: http://example.com/longish/path/to/resource/here &quot;Optional Title Here&quot; 链接定义仅用于在Markdown处理期间创建链接，并在HTML输出中从文档中剥离链接定义。 链接定义名称可能由字母，数字，空格和标点符号组成 - 但它们不区分大小写。 例如。 这两个链接： [link text][a] [link text][A] 是等同的。 隐含链接名称 快捷方式允许您省略链接的名称，在这种情况下链接文本本身被用作名称。 只需使用一组空白的方括号 - 例如，将单词“Google”链接到google.com网站，您可以简单地编写： [Google][] 然后定义链接： [Google]: http://google.com/ 由于链接名称可能包含空格，因此此快捷键甚至适用于链接文本中的多个单词： Visit [Daring Fireball][] for more information. 然后定义链接： [Daring Fireball]: http://daringfireball.net/ 链接定义可以放置在Markdown文档的任何位置。 我倾向于在他们使用的每个段落之后立即放置它们，但是如果你愿意，可以将它们全部放在文档的末尾，有点像脚注。 以下是实际参考链接的示例： I get 10 times more traffic from [Google] [1] than from [Yahoo] [2] or [MSN] [3]. [1]: http://google.com/ &quot;Google&quot; [2]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [3]: http://search.msn.com/ &quot;MSN Search&quot; 使用隐式链接名称快捷方式，可以改为编写： I get 10 times more traffic from [Google][] than from [Yahoo][] or [MSN][]. [google]: http://google.com/ &quot;Google&quot; [yahoo]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [msn]: http://search.msn.com/ &quot;MSN Search&quot; 以上两个示例都会生成以下HTML输出： 1234&lt;p&gt;I get 10 times more traffic from &lt;a href="http://google.com/"title="Google"&gt;Google&lt;/a&gt; than from&lt;a href="http://search.yahoo.com/" title="Yahoo Search"&gt;Yahoo&lt;/a&gt;or &lt;a href="http://search.msn.com/" title="MSN Search"&gt;MSN&lt;/a&gt;.&lt;/p&gt; 为了比较，这里是使用Markdown的内联链接样式编写的同一段： I get 10 times more traffic from [Google](http://google.com/ &quot;Google&quot;) than from [Yahoo](http://search.yahoo.com/ &quot;Yahoo Search&quot;) or [MSN](http://search.msn.com/ &quot;MSN Search&quot;). 引用式链接的关键不在于它们更容易编写。 关键是，使用参考样式的链接，您的文档来源更具可读性。 比较上面的例子：使用参考样式的链接，该段本身只有81个字符长; 带有内联式链接，它有176个字符; 并作为原始HTML，它是234个字符。 在原始HTML中，标记多于文本。 使用Markdown的参考风格链接，源文档与浏览器中呈现的最终输出非常相似。 通过允许您将标记相关的元数据移出段落，您可以添加链接而不中断散文的叙述流程。 重点 Markdown将星号（*）和下划线（_）作为重点指标。 用一个 * 或 _ 包裹的文本将用一个HTML &lt;em&gt; 标签包装; 用两个 * 或 _ 将被包含一个HTML &lt;strong&gt; 标签。 例如，这个输入： *single asterisks* _single underscores_ **double asterisks** __double underscores__ 会产生： 1234567&lt;em&gt;single asterisks&lt;/em&gt;&lt;em&gt;single underscores&lt;/em&gt;&lt;strong&gt;double asterisks&lt;/strong&gt;&lt;strong&gt;double underscores&lt;/strong&gt; 你可以使用你喜欢的任何风格; 唯一的限制是必须使用相同的字符来打开和关闭重点范围。 强调可以用在词的中间： un*frigging*believable 但是如果用空格包围 * 或 _ ，它将被视为文字星号或下划线。 要在原本用作强调分隔符的位置生成文字星号或下划线，可以使用反斜杠进行转义： \*this text is surrounded by literal asterisks\* 代码 为了表示一段代码，用反引号引起来（`）。 与预格式化代码块不同，代码范围指示正常段落内的代码。 例如： Use the `printf()` function. 会产生： 1&lt;p&gt;Use the &lt;code&gt;printf()&lt;/code&gt; function.&lt;/p&gt; 要在代码范围内包含文字反引号字符，可以使用多个反引号作为开始和结束分隔符： ``There is a literal backtick (`) here.`` 这将产生这样的结果： 1&lt;p&gt;&lt;code&gt;There is a literal backtick (`) here.&lt;/code&gt;&lt;/p&gt; 代码跨度周围的反引号分隔符可能包含空格 - 开放后一个，关闭之前一个。 这使您可以在代码范围的开头或结尾放置文字反引号字符： A single backtick in a code span: `` ` `` A backtick-delimited string in a code span: `` `foo` `` 会产生： 123&lt;p&gt;A single backtick in a code span: &lt;code&gt;`&lt;/code&gt;&lt;/p&gt;&lt;p&gt;A backtick-delimited string in a code span: &lt;code&gt;`foo`&lt;/code&gt;&lt;/p&gt; 通过代码跨度，＆符号和尖括号会自动编码为HTML实体，这样可以轻松包含示例HTML标记。 Markdown会变成这样： Please don&apos;t use any `&lt;blink&gt;` tags. 成： 1&lt;p&gt;Please don't use any &lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt; 你可以写这个： `&amp;#8212;` is the decimal-encoded equivalent of `&amp;mdash;`. 产生： 12&lt;p&gt;&lt;code&gt;&amp;amp;#8212;&lt;/code&gt; is the decimal-encodedequivalent of &lt;code&gt;&amp;amp;mdash;&lt;/code&gt;.&lt;/p&gt; 图片 无可否认，设计用于将图像置于纯文本文档格式的“自然”语法相当困难。 Markdown使用图像语法，旨在类似链接的语法，允许两种样式：内联 和 引用。 内联图像语法如下所示： ![Alt text](/path/to/img.jpg) ![Alt text](/path/to/img.jpg &quot;Optional title&quot;) 那是： 感叹号： !; 然后是一组方括号，其中包含图像的 alt 属性文本; 接着是一组括号，其中包含图像的URL或路径，以及用双引号或单引号括起来的可选 title 属性。 参考风格的图像语法如下所示： ![Alt text][id] 其中“id”是定义的图像引用的名称。 图像引用是使用与链接引用相同的语法定义的： [id]: url/to/image &quot;Optional title attribute&quot; 在撰写本文时，Markdown没有指定图像尺寸的语法; 如果这对你来说很重要，你可以简单地使用普通的HTML标签 &lt;img&gt; 标签。 杂项 自动链接 Markdown支持创建URL和电子邮件地址的“自动”链接的快捷方式：只需使用尖括号围绕URL或电子邮件地址即可。 这意味着如果你想显示一个URL或电子邮件地址的实际文本，并且它也是一个可点击的链接，你可以这样做： &lt;http://example.com/&gt; Markdown将把它变成： 1&lt;a href="http://example.com/"&gt;http://example.com/&lt;/a&gt; 电子邮件地址的自动链接的工作方式与此类似，但Markdown还会执行一些随机化的十进制和十六进制实体编码，以帮助屏蔽地址收集spambots的地址。 例如，Markdown会变成这样： &lt;address@example.com&gt; 变成这样的东西： 1234&lt;a href="&amp;#x6D;&amp;#x61;i&amp;#x6C;&amp;#x74;&amp;#x6F;:&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;"&gt;&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt; 这将在浏览器中呈现为“address@example.com”的可点击链接。 （这种实体编码的技巧确实会欺骗很多（如果不是绝大多数）地址获取机器人，但它绝对不会欺骗所有这些机器人。总比没有好，但以这种方式发布的地址可能最终会开始接收 垃圾邮件。） 反斜线转义 Markdown允许您使用反斜线转义来生成文字字符，否则这些字符在Markdown的格式化语法中会有特殊含义。 例如，如果您想用文字星号（而不是HTML &lt;em&gt; 标签）标记单词，则可以在星号之前使用反斜杠，如下所示： \*literal asterisks\* Markdown为以下字符提供反斜杠转义符： \ backslash ` backtick * asterisk _ underscore {} curly braces [] square brackets () parentheses # hash mark + plus sign - minus sign (hyphen) . dot ! exclamation mark]]></content>
      <categories>
        <category>API</category>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>API</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
